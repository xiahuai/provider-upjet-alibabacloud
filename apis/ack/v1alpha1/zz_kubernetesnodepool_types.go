// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AutoRepairPolicyInitParameters struct {

	// Whether to allow node restart.
	RestartNode *bool `json:"restartNode,omitempty" tf:"restart_node,omitempty"`
}

type AutoRepairPolicyObservation struct {

	// Whether to allow node restart.
	RestartNode *bool `json:"restartNode,omitempty" tf:"restart_node,omitempty"`
}

type AutoRepairPolicyParameters struct {

	// Whether to allow node restart.
	// +kubebuilder:validation:Optional
	RestartNode *bool `json:"restartNode,omitempty" tf:"restart_node,omitempty"`
}

type AutoUpgradePolicyInitParameters struct {

	// Specifies whether  to automatically update the kubelet. Valid values: true: yes; false: no.
	AutoUpgradeKubelet *bool `json:"autoUpgradeKubelet,omitempty" tf:"auto_upgrade_kubelet,omitempty"`
}

type AutoUpgradePolicyObservation struct {

	// Specifies whether  to automatically update the kubelet. Valid values: true: yes; false: no.
	AutoUpgradeKubelet *bool `json:"autoUpgradeKubelet,omitempty" tf:"auto_upgrade_kubelet,omitempty"`
}

type AutoUpgradePolicyParameters struct {

	// Specifies whether  to automatically update the kubelet. Valid values: true: yes; false: no.
	// +kubebuilder:validation:Optional
	AutoUpgradeKubelet *bool `json:"autoUpgradeKubelet,omitempty" tf:"auto_upgrade_kubelet,omitempty"`
}

type AutoVulFixPolicyInitParameters struct {

	// Whether to allow node restart.
	RestartNode *bool `json:"restartNode,omitempty" tf:"restart_node,omitempty"`

	// The severity levels of vulnerabilities that is allowed to automatically patch. Multiple severity levels are separated by commas (,).
	VulLevel *string `json:"vulLevel,omitempty" tf:"vul_level,omitempty"`
}

type AutoVulFixPolicyObservation struct {

	// Whether to allow node restart.
	RestartNode *bool `json:"restartNode,omitempty" tf:"restart_node,omitempty"`

	// The severity levels of vulnerabilities that is allowed to automatically patch. Multiple severity levels are separated by commas (,).
	VulLevel *string `json:"vulLevel,omitempty" tf:"vul_level,omitempty"`
}

type AutoVulFixPolicyParameters struct {

	// Whether to allow node restart.
	// +kubebuilder:validation:Optional
	RestartNode *bool `json:"restartNode,omitempty" tf:"restart_node,omitempty"`

	// The severity levels of vulnerabilities that is allowed to automatically patch. Multiple severity levels are separated by commas (,).
	// +kubebuilder:validation:Optional
	VulLevel *string `json:"vulLevel,omitempty" tf:"vul_level,omitempty"`
}

type DataDisksInitParameters struct {

	// Whether to automatically mount the data disk. Valid values: true and false.
	AutoFormat *string `json:"autoFormat,omitempty" tf:"auto_format,omitempty"`

	// The ID of the automatic snapshot policy that you want to apply to the system disk.
	AutoSnapshotPolicyID *string `json:"autoSnapshotPolicyId,omitempty" tf:"auto_snapshot_policy_id,omitempty"`

	// Whether the data disk is enabled with Burst (performance Burst). This is configured when the disk type is cloud_auto.
	BurstingEnabled *bool `json:"burstingEnabled,omitempty" tf:"bursting_enabled,omitempty"`

	// The type of data disk. Default value: cloud_efficiency. Valid values:
	Category *string `json:"category,omitempty" tf:"category,omitempty"`

	// The mount target of data disk N. Valid values of N: 1 to 16. If you do not specify this parameter, the system automatically assigns a mount target when Auto Scaling creates ECS instances. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
	Device *string `json:"device,omitempty" tf:"device,omitempty"`

	// Specifies whether to encrypt data disks. Valid values: true and false. Default to false.
	Encrypted *string `json:"encrypted,omitempty" tf:"encrypted,omitempty"`

	// The type of the mounted file system. Works when auto_format is true. Optional value: ext4, xfs.
	FileSystem *string `json:"fileSystem,omitempty" tf:"file_system,omitempty"`

	// The kms key id used to encrypt the data disk. It takes effect when encrypted is true.
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// The Mount path. Works when auto_format is true.
	MountTarget *string `json:"mountTarget,omitempty" tf:"mount_target,omitempty"`

	// The length is 2~128 English or Chinese characters. It must start with an uppercase or lowr letter or a Chinese character and cannot start with http:// or https. Can contain numbers, colons (:), underscores (_), or dashes (-). It will be overwritten if auto_format is set.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Worker node data disk performance level, when category values cloud_essd, the optional values are PL0, PL1, PL2 or PL3, but the specific performance level is related to the disk capacity. For more information, see Enhanced SSDs. Default is PL1.
	PerformanceLevel *string `json:"performanceLevel,omitempty" tf:"performance_level,omitempty"`

	// The read/write IOPS preconfigured for the data disk, which is configured when the disk type is cloud_auto.
	ProvisionedIops *float64 `json:"provisionedIops,omitempty" tf:"provisioned_iops,omitempty"`

	// The size of a data disk, Its valid value range [40~32768] in GB. Default to 40.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The ID of the snapshot that you want to use to create data disk N. Valid values of N: 1 to 16. If you specify this parameter, DataDisk.N.Size is ignored. The size of the disk is the same as the size of the specified snapshot. If you specify a snapshot that is created on or before July 15, 2013, the operation fails and InvalidSnapshot.TooOld is returned.
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`
}

type DataDisksObservation struct {

	// Whether to automatically mount the data disk. Valid values: true and false.
	AutoFormat *string `json:"autoFormat,omitempty" tf:"auto_format,omitempty"`

	// The ID of the automatic snapshot policy that you want to apply to the system disk.
	AutoSnapshotPolicyID *string `json:"autoSnapshotPolicyId,omitempty" tf:"auto_snapshot_policy_id,omitempty"`

	// Whether the data disk is enabled with Burst (performance Burst). This is configured when the disk type is cloud_auto.
	BurstingEnabled *bool `json:"burstingEnabled,omitempty" tf:"bursting_enabled,omitempty"`

	// The type of data disk. Default value: cloud_efficiency. Valid values:
	Category *string `json:"category,omitempty" tf:"category,omitempty"`

	// The mount target of data disk N. Valid values of N: 1 to 16. If you do not specify this parameter, the system automatically assigns a mount target when Auto Scaling creates ECS instances. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
	Device *string `json:"device,omitempty" tf:"device,omitempty"`

	// Specifies whether to encrypt data disks. Valid values: true and false. Default to false.
	Encrypted *string `json:"encrypted,omitempty" tf:"encrypted,omitempty"`

	// The type of the mounted file system. Works when auto_format is true. Optional value: ext4, xfs.
	FileSystem *string `json:"fileSystem,omitempty" tf:"file_system,omitempty"`

	// The kms key id used to encrypt the data disk. It takes effect when encrypted is true.
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// The Mount path. Works when auto_format is true.
	MountTarget *string `json:"mountTarget,omitempty" tf:"mount_target,omitempty"`

	// The length is 2~128 English or Chinese characters. It must start with an uppercase or lowr letter or a Chinese character and cannot start with http:// or https. Can contain numbers, colons (:), underscores (_), or dashes (-). It will be overwritten if auto_format is set.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Worker node data disk performance level, when category values cloud_essd, the optional values are PL0, PL1, PL2 or PL3, but the specific performance level is related to the disk capacity. For more information, see Enhanced SSDs. Default is PL1.
	PerformanceLevel *string `json:"performanceLevel,omitempty" tf:"performance_level,omitempty"`

	// The read/write IOPS preconfigured for the data disk, which is configured when the disk type is cloud_auto.
	ProvisionedIops *float64 `json:"provisionedIops,omitempty" tf:"provisioned_iops,omitempty"`

	// The size of a data disk, Its valid value range [40~32768] in GB. Default to 40.
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The ID of the snapshot that you want to use to create data disk N. Valid values of N: 1 to 16. If you specify this parameter, DataDisk.N.Size is ignored. The size of the disk is the same as the size of the specified snapshot. If you specify a snapshot that is created on or before July 15, 2013, the operation fails and InvalidSnapshot.TooOld is returned.
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`
}

type DataDisksParameters struct {

	// Whether to automatically mount the data disk. Valid values: true and false.
	// +kubebuilder:validation:Optional
	AutoFormat *string `json:"autoFormat,omitempty" tf:"auto_format,omitempty"`

	// The ID of the automatic snapshot policy that you want to apply to the system disk.
	// +kubebuilder:validation:Optional
	AutoSnapshotPolicyID *string `json:"autoSnapshotPolicyId,omitempty" tf:"auto_snapshot_policy_id,omitempty"`

	// Whether the data disk is enabled with Burst (performance Burst). This is configured when the disk type is cloud_auto.
	// +kubebuilder:validation:Optional
	BurstingEnabled *bool `json:"burstingEnabled,omitempty" tf:"bursting_enabled,omitempty"`

	// The type of data disk. Default value: cloud_efficiency. Valid values:
	// +kubebuilder:validation:Optional
	Category *string `json:"category,omitempty" tf:"category,omitempty"`

	// The mount target of data disk N. Valid values of N: 1 to 16. If you do not specify this parameter, the system automatically assigns a mount target when Auto Scaling creates ECS instances. The name of the mount target ranges from /dev/xvdb to /dev/xvdz.
	// +kubebuilder:validation:Optional
	Device *string `json:"device,omitempty" tf:"device,omitempty"`

	// Specifies whether to encrypt data disks. Valid values: true and false. Default to false.
	// +kubebuilder:validation:Optional
	Encrypted *string `json:"encrypted,omitempty" tf:"encrypted,omitempty"`

	// The type of the mounted file system. Works when auto_format is true. Optional value: ext4, xfs.
	// +kubebuilder:validation:Optional
	FileSystem *string `json:"fileSystem,omitempty" tf:"file_system,omitempty"`

	// The kms key id used to encrypt the data disk. It takes effect when encrypted is true.
	// +kubebuilder:validation:Optional
	KMSKeyID *string `json:"kmsKeyId,omitempty" tf:"kms_key_id,omitempty"`

	// The Mount path. Works when auto_format is true.
	// +kubebuilder:validation:Optional
	MountTarget *string `json:"mountTarget,omitempty" tf:"mount_target,omitempty"`

	// The length is 2~128 English or Chinese characters. It must start with an uppercase or lowr letter or a Chinese character and cannot start with http:// or https. Can contain numbers, colons (:), underscores (_), or dashes (-). It will be overwritten if auto_format is set.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Worker node data disk performance level, when category values cloud_essd, the optional values are PL0, PL1, PL2 or PL3, but the specific performance level is related to the disk capacity. For more information, see Enhanced SSDs. Default is PL1.
	// +kubebuilder:validation:Optional
	PerformanceLevel *string `json:"performanceLevel,omitempty" tf:"performance_level,omitempty"`

	// The read/write IOPS preconfigured for the data disk, which is configured when the disk type is cloud_auto.
	// +kubebuilder:validation:Optional
	ProvisionedIops *float64 `json:"provisionedIops,omitempty" tf:"provisioned_iops,omitempty"`

	// The size of a data disk, Its valid value range [40~32768] in GB. Default to 40.
	// +kubebuilder:validation:Optional
	Size *float64 `json:"size,omitempty" tf:"size,omitempty"`

	// The ID of the snapshot that you want to use to create data disk N. Valid values of N: 1 to 16. If you specify this parameter, DataDisk.N.Size is ignored. The size of the disk is the same as the size of the specified snapshot. If you specify a snapshot that is created on or before July 15, 2013, the operation fails and InvalidSnapshot.TooOld is returned.
	// +kubebuilder:validation:Optional
	SnapshotID *string `json:"snapshotId,omitempty" tf:"snapshot_id,omitempty"`
}

type KubeletConfigurationInitParameters struct {

	// Allowed sysctl mode whitelist.
	AllowedUnsafeSysctls []*string `json:"allowedUnsafeSysctls,omitempty" tf:"allowed_unsafe_sysctls,omitempty"`

	// CPU CFS quota constraint switch.
	CPUCfsQuota *string `json:"cpuCfsQuota,omitempty" tf:"cpu_cfs_quota,omitempty"`

	// CPU CFS quota period value.
	CPUCfsQuotaPeriod *string `json:"cpuCfsQuotaPeriod,omitempty" tf:"cpu_cfs_quota_period,omitempty"`

	// Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is none or static.
	CPUManagerPolicy *string `json:"cpuManagerPolicy,omitempty" tf:"cpu_manager_policy,omitempty"`

	// The list of IP addresses of the cluster DNS servers.
	ClusterDNS []*string `json:"clusterDns,omitempty" tf:"cluster_dns,omitempty"`

	// The maximum number of log files that can exist in each container.
	ContainerLogMaxFiles *string `json:"containerLogMaxFiles,omitempty" tf:"container_log_max_files,omitempty"`

	// The maximum size that can be reached before a log file is rotated.
	ContainerLogMaxSize *string `json:"containerLogMaxSize,omitempty" tf:"container_log_max_size,omitempty"`

	// Specifies the maximum number of concurrent workers required to perform log rotation operations.
	ContainerLogMaxWorkers *string `json:"containerLogMaxWorkers,omitempty" tf:"container_log_max_workers,omitempty"`

	// Specifies the duration for which container logs are monitored for log rotation.
	ContainerLogMonitorInterval *string `json:"containerLogMonitorInterval,omitempty" tf:"container_log_monitor_interval,omitempty"`

	// Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding event_record_qps. It is only used when event_record_qps is greater than 0. Valid value is [0-100].
	EventBurst *string `json:"eventBurst,omitempty" tf:"event_burst,omitempty"`

	// Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is [0-50].
	EventRecordQPS *string `json:"eventRecordQps,omitempty" tf:"event_record_qps,omitempty"`

	// Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: {"memory.available" = "300Mi"}.
	// +mapType=granular
	EvictionHard map[string]*string `json:"evictionHard,omitempty" tf:"eviction_hard,omitempty"`

	// Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: {"memory.available" = "300Mi"}.
	// +mapType=granular
	EvictionSoft map[string]*string `json:"evictionSoft,omitempty" tf:"eviction_soft,omitempty"`

	// Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: {"memory.available" = "30s"}.
	// +mapType=granular
	EvictionSoftGracePeriod map[string]*string `json:"evictionSoftGracePeriod,omitempty" tf:"eviction_soft_grace_period,omitempty"`

	// Feature switch to enable configuration of experimental features.
	// +mapType=granular
	FeatureGates map[string]*bool `json:"featureGates,omitempty" tf:"feature_gates,omitempty"`

	// If the image usage exceeds this threshold, image garbage collection will continue.
	ImageGcHighThresholdPercent *string `json:"imageGcHighThresholdPercent,omitempty" tf:"image_gc_high_threshold_percent,omitempty"`

	// Image garbage collection is not performed when the image usage is below this threshold.
	ImageGcLowThresholdPercent *string `json:"imageGcLowThresholdPercent,omitempty" tf:"image_gc_low_threshold_percent,omitempty"`

	// Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is [0-100].
	KubeAPIBurst *string `json:"kubeApiBurst,omitempty" tf:"kube_api_burst,omitempty"`

	// Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is [0-50].
	KubeAPIQPS *string `json:"kubeApiQps,omitempty" tf:"kube_api_qps,omitempty"`

	// Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See compute resources for more details.
	// +mapType=granular
	KubeReserved map[string]*string `json:"kubeReserved,omitempty" tf:"kube_reserved,omitempty"`

	// The maximum number of running pods.
	MaxPods *string `json:"maxPods,omitempty" tf:"max_pods,omitempty"`

	// The policy to be used by the memory manager.
	MemoryManagerPolicy *string `json:"memoryManagerPolicy,omitempty" tf:"memory_manager_policy,omitempty"`

	// The maximum number of PIDs that can be used in a Pod.
	PodPidsLimit *string `json:"podPidsLimit,omitempty" tf:"pod_pids_limit,omitempty"`

	// Read-only port number.
	ReadOnlyPort *string `json:"readOnlyPort,omitempty" tf:"read_only_port,omitempty"`

	// Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding registry_pull_qps. Only used if registry_pull_qps is greater than 0. Valid value is [0-100].
	RegistryBurst *string `json:"registryBurst,omitempty" tf:"registry_burst,omitempty"`

	// Same as registryPullQPS. The limit of registry pulls per second. Setting it to 0 means no limit. Valid value is [0-50].
	RegistryPullQPS *string `json:"registryPullQps,omitempty" tf:"registry_pull_qps,omitempty"`

	// Reserve memory for NUMA nodes. See reserved_memory below.
	ReservedMemory []ReservedMemoryInitParameters `json:"reservedMemory,omitempty" tf:"reserved_memory,omitempty"`

	// Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version < 1.9 or an Aufs storage backend. Valid value is true or false.
	SerializeImagePulls *string `json:"serializeImagePulls,omitempty" tf:"serialize_image_pulls,omitempty"`

	// Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See compute resources for more details.
	// +mapType=granular
	SystemReserved map[string]*string `json:"systemReserved,omitempty" tf:"system_reserved,omitempty"`

	// Name of the Topology Manager policy used.
	TopologyManagerPolicy *string `json:"topologyManagerPolicy,omitempty" tf:"topology_manager_policy,omitempty"`

	// OpenTelemetry tracks the configuration information for client settings versioning. See tracing below.
	Tracing []TracingInitParameters `json:"tracing,omitempty" tf:"tracing,omitempty"`
}

type KubeletConfigurationObservation struct {

	// Allowed sysctl mode whitelist.
	AllowedUnsafeSysctls []*string `json:"allowedUnsafeSysctls,omitempty" tf:"allowed_unsafe_sysctls,omitempty"`

	// CPU CFS quota constraint switch.
	CPUCfsQuota *string `json:"cpuCfsQuota,omitempty" tf:"cpu_cfs_quota,omitempty"`

	// CPU CFS quota period value.
	CPUCfsQuotaPeriod *string `json:"cpuCfsQuotaPeriod,omitempty" tf:"cpu_cfs_quota_period,omitempty"`

	// Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is none or static.
	CPUManagerPolicy *string `json:"cpuManagerPolicy,omitempty" tf:"cpu_manager_policy,omitempty"`

	// The list of IP addresses of the cluster DNS servers.
	ClusterDNS []*string `json:"clusterDns,omitempty" tf:"cluster_dns,omitempty"`

	// The maximum number of log files that can exist in each container.
	ContainerLogMaxFiles *string `json:"containerLogMaxFiles,omitempty" tf:"container_log_max_files,omitempty"`

	// The maximum size that can be reached before a log file is rotated.
	ContainerLogMaxSize *string `json:"containerLogMaxSize,omitempty" tf:"container_log_max_size,omitempty"`

	// Specifies the maximum number of concurrent workers required to perform log rotation operations.
	ContainerLogMaxWorkers *string `json:"containerLogMaxWorkers,omitempty" tf:"container_log_max_workers,omitempty"`

	// Specifies the duration for which container logs are monitored for log rotation.
	ContainerLogMonitorInterval *string `json:"containerLogMonitorInterval,omitempty" tf:"container_log_monitor_interval,omitempty"`

	// Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding event_record_qps. It is only used when event_record_qps is greater than 0. Valid value is [0-100].
	EventBurst *string `json:"eventBurst,omitempty" tf:"event_burst,omitempty"`

	// Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is [0-50].
	EventRecordQPS *string `json:"eventRecordQps,omitempty" tf:"event_record_qps,omitempty"`

	// Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: {"memory.available" = "300Mi"}.
	// +mapType=granular
	EvictionHard map[string]*string `json:"evictionHard,omitempty" tf:"eviction_hard,omitempty"`

	// Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: {"memory.available" = "300Mi"}.
	// +mapType=granular
	EvictionSoft map[string]*string `json:"evictionSoft,omitempty" tf:"eviction_soft,omitempty"`

	// Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: {"memory.available" = "30s"}.
	// +mapType=granular
	EvictionSoftGracePeriod map[string]*string `json:"evictionSoftGracePeriod,omitempty" tf:"eviction_soft_grace_period,omitempty"`

	// Feature switch to enable configuration of experimental features.
	// +mapType=granular
	FeatureGates map[string]*bool `json:"featureGates,omitempty" tf:"feature_gates,omitempty"`

	// If the image usage exceeds this threshold, image garbage collection will continue.
	ImageGcHighThresholdPercent *string `json:"imageGcHighThresholdPercent,omitempty" tf:"image_gc_high_threshold_percent,omitempty"`

	// Image garbage collection is not performed when the image usage is below this threshold.
	ImageGcLowThresholdPercent *string `json:"imageGcLowThresholdPercent,omitempty" tf:"image_gc_low_threshold_percent,omitempty"`

	// Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is [0-100].
	KubeAPIBurst *string `json:"kubeApiBurst,omitempty" tf:"kube_api_burst,omitempty"`

	// Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is [0-50].
	KubeAPIQPS *string `json:"kubeApiQps,omitempty" tf:"kube_api_qps,omitempty"`

	// Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See compute resources for more details.
	// +mapType=granular
	KubeReserved map[string]*string `json:"kubeReserved,omitempty" tf:"kube_reserved,omitempty"`

	// The maximum number of running pods.
	MaxPods *string `json:"maxPods,omitempty" tf:"max_pods,omitempty"`

	// The policy to be used by the memory manager.
	MemoryManagerPolicy *string `json:"memoryManagerPolicy,omitempty" tf:"memory_manager_policy,omitempty"`

	// The maximum number of PIDs that can be used in a Pod.
	PodPidsLimit *string `json:"podPidsLimit,omitempty" tf:"pod_pids_limit,omitempty"`

	// Read-only port number.
	ReadOnlyPort *string `json:"readOnlyPort,omitempty" tf:"read_only_port,omitempty"`

	// Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding registry_pull_qps. Only used if registry_pull_qps is greater than 0. Valid value is [0-100].
	RegistryBurst *string `json:"registryBurst,omitempty" tf:"registry_burst,omitempty"`

	// Same as registryPullQPS. The limit of registry pulls per second. Setting it to 0 means no limit. Valid value is [0-50].
	RegistryPullQPS *string `json:"registryPullQps,omitempty" tf:"registry_pull_qps,omitempty"`

	// Reserve memory for NUMA nodes. See reserved_memory below.
	ReservedMemory []ReservedMemoryObservation `json:"reservedMemory,omitempty" tf:"reserved_memory,omitempty"`

	// Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version < 1.9 or an Aufs storage backend. Valid value is true or false.
	SerializeImagePulls *string `json:"serializeImagePulls,omitempty" tf:"serialize_image_pulls,omitempty"`

	// Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See compute resources for more details.
	// +mapType=granular
	SystemReserved map[string]*string `json:"systemReserved,omitempty" tf:"system_reserved,omitempty"`

	// Name of the Topology Manager policy used.
	TopologyManagerPolicy *string `json:"topologyManagerPolicy,omitempty" tf:"topology_manager_policy,omitempty"`

	// OpenTelemetry tracks the configuration information for client settings versioning. See tracing below.
	Tracing []TracingObservation `json:"tracing,omitempty" tf:"tracing,omitempty"`
}

type KubeletConfigurationParameters struct {

	// Allowed sysctl mode whitelist.
	// +kubebuilder:validation:Optional
	AllowedUnsafeSysctls []*string `json:"allowedUnsafeSysctls,omitempty" tf:"allowed_unsafe_sysctls,omitempty"`

	// CPU CFS quota constraint switch.
	// +kubebuilder:validation:Optional
	CPUCfsQuota *string `json:"cpuCfsQuota,omitempty" tf:"cpu_cfs_quota,omitempty"`

	// CPU CFS quota period value.
	// +kubebuilder:validation:Optional
	CPUCfsQuotaPeriod *string `json:"cpuCfsQuotaPeriod,omitempty" tf:"cpu_cfs_quota_period,omitempty"`

	// Same as cpuManagerPolicy. The name of the policy to use. Requires the CPUManager feature gate to be enabled. Valid value is none or static.
	// +kubebuilder:validation:Optional
	CPUManagerPolicy *string `json:"cpuManagerPolicy,omitempty" tf:"cpu_manager_policy,omitempty"`

	// The list of IP addresses of the cluster DNS servers.
	// +kubebuilder:validation:Optional
	ClusterDNS []*string `json:"clusterDns,omitempty" tf:"cluster_dns,omitempty"`

	// The maximum number of log files that can exist in each container.
	// +kubebuilder:validation:Optional
	ContainerLogMaxFiles *string `json:"containerLogMaxFiles,omitempty" tf:"container_log_max_files,omitempty"`

	// The maximum size that can be reached before a log file is rotated.
	// +kubebuilder:validation:Optional
	ContainerLogMaxSize *string `json:"containerLogMaxSize,omitempty" tf:"container_log_max_size,omitempty"`

	// Specifies the maximum number of concurrent workers required to perform log rotation operations.
	// +kubebuilder:validation:Optional
	ContainerLogMaxWorkers *string `json:"containerLogMaxWorkers,omitempty" tf:"container_log_max_workers,omitempty"`

	// Specifies the duration for which container logs are monitored for log rotation.
	// +kubebuilder:validation:Optional
	ContainerLogMonitorInterval *string `json:"containerLogMonitorInterval,omitempty" tf:"container_log_monitor_interval,omitempty"`

	// Same as eventBurst. The maximum size of a burst of event creations, temporarily allows event creations to burst to this number, while still not exceeding event_record_qps. It is only used when event_record_qps is greater than 0. Valid value is [0-100].
	// +kubebuilder:validation:Optional
	EventBurst *string `json:"eventBurst,omitempty" tf:"event_burst,omitempty"`

	// Same as eventRecordQPS. The maximum event creations per second. If 0, there is no limit enforced. Valid value is [0-50].
	// +kubebuilder:validation:Optional
	EventRecordQPS *string `json:"eventRecordQps,omitempty" tf:"event_record_qps,omitempty"`

	// Same as evictionHard. The map of signal names to quantities that defines hard eviction thresholds. For example: {"memory.available" = "300Mi"}.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	EvictionHard map[string]*string `json:"evictionHard,omitempty" tf:"eviction_hard,omitempty"`

	// Same as evictionSoft. The map of signal names to quantities that defines soft eviction thresholds. For example: {"memory.available" = "300Mi"}.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	EvictionSoft map[string]*string `json:"evictionSoft,omitempty" tf:"eviction_soft,omitempty"`

	// Same as evictionSoftGracePeriod. The map of signal names to quantities that defines grace periods for each soft eviction signal. For example: {"memory.available" = "30s"}.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	EvictionSoftGracePeriod map[string]*string `json:"evictionSoftGracePeriod,omitempty" tf:"eviction_soft_grace_period,omitempty"`

	// Feature switch to enable configuration of experimental features.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	FeatureGates map[string]*bool `json:"featureGates,omitempty" tf:"feature_gates,omitempty"`

	// If the image usage exceeds this threshold, image garbage collection will continue.
	// +kubebuilder:validation:Optional
	ImageGcHighThresholdPercent *string `json:"imageGcHighThresholdPercent,omitempty" tf:"image_gc_high_threshold_percent,omitempty"`

	// Image garbage collection is not performed when the image usage is below this threshold.
	// +kubebuilder:validation:Optional
	ImageGcLowThresholdPercent *string `json:"imageGcLowThresholdPercent,omitempty" tf:"image_gc_low_threshold_percent,omitempty"`

	// Same as kubeAPIBurst. The burst to allow while talking with kubernetes api-server. Valid value is [0-100].
	// +kubebuilder:validation:Optional
	KubeAPIBurst *string `json:"kubeApiBurst,omitempty" tf:"kube_api_burst,omitempty"`

	// Same as kubeAPIQPS. The QPS to use while talking with kubernetes api-server. Valid value is [0-50].
	// +kubebuilder:validation:Optional
	KubeAPIQPS *string `json:"kubeApiQps,omitempty" tf:"kube_api_qps,omitempty"`

	// Same as kubeReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for kubernetes system components. Currently, cpu, memory and local storage for root file system are supported. See compute resources for more details.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	KubeReserved map[string]*string `json:"kubeReserved,omitempty" tf:"kube_reserved,omitempty"`

	// The maximum number of running pods.
	// +kubebuilder:validation:Optional
	MaxPods *string `json:"maxPods,omitempty" tf:"max_pods,omitempty"`

	// The policy to be used by the memory manager.
	// +kubebuilder:validation:Optional
	MemoryManagerPolicy *string `json:"memoryManagerPolicy,omitempty" tf:"memory_manager_policy,omitempty"`

	// The maximum number of PIDs that can be used in a Pod.
	// +kubebuilder:validation:Optional
	PodPidsLimit *string `json:"podPidsLimit,omitempty" tf:"pod_pids_limit,omitempty"`

	// Read-only port number.
	// +kubebuilder:validation:Optional
	ReadOnlyPort *string `json:"readOnlyPort,omitempty" tf:"read_only_port,omitempty"`

	// Same as registryBurst. The maximum size of burst pulls, temporarily allows pulls to burst to this number, while still not exceeding registry_pull_qps. Only used if registry_pull_qps is greater than 0. Valid value is [0-100].
	// +kubebuilder:validation:Optional
	RegistryBurst *string `json:"registryBurst,omitempty" tf:"registry_burst,omitempty"`

	// Same as registryPullQPS. The limit of registry pulls per second. Setting it to 0 means no limit. Valid value is [0-50].
	// +kubebuilder:validation:Optional
	RegistryPullQPS *string `json:"registryPullQps,omitempty" tf:"registry_pull_qps,omitempty"`

	// Reserve memory for NUMA nodes. See reserved_memory below.
	// +kubebuilder:validation:Optional
	ReservedMemory []ReservedMemoryParameters `json:"reservedMemory,omitempty" tf:"reserved_memory,omitempty"`

	// Same as serializeImagePulls. When enabled, it tells the Kubelet to pull images one at a time. We recommend not changing the default value on nodes that run docker daemon with version < 1.9 or an Aufs storage backend. Valid value is true or false.
	// +kubebuilder:validation:Optional
	SerializeImagePulls *string `json:"serializeImagePulls,omitempty" tf:"serialize_image_pulls,omitempty"`

	// Same as systemReserved. The set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs that describe resources reserved for non-kubernetes components. Currently, only cpu and memory are supported. See compute resources for more details.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	SystemReserved map[string]*string `json:"systemReserved,omitempty" tf:"system_reserved,omitempty"`

	// Name of the Topology Manager policy used.
	// +kubebuilder:validation:Optional
	TopologyManagerPolicy *string `json:"topologyManagerPolicy,omitempty" tf:"topology_manager_policy,omitempty"`

	// OpenTelemetry tracks the configuration information for client settings versioning. See tracing below.
	// +kubebuilder:validation:Optional
	Tracing []TracingParameters `json:"tracing,omitempty" tf:"tracing,omitempty"`
}

type KubernetesNodePoolInitParameters struct {

	// Whether to enable automatic renewal for nodes in the node pool takes effect only when instance_charge_type is set to PrePaid. Default value: false. Valid values:
	AutoRenew *bool `json:"autoRenew,omitempty" tf:"auto_renew,omitempty"`

	// The automatic renewal period of nodes in the node pool takes effect only when you select Prepaid and Automatic Renewal, and is a required value. When PeriodUnit = Month, the value range is {1, 2, 3, 6, 12}. Default value: 1.
	AutoRenewPeriod *float64 `json:"autoRenewPeriod,omitempty" tf:"auto_renew_period,omitempty"`

	// Node CPU management policies. Default value: none. When the cluster version is 1.12.6 or later, the following two policies are supported:
	CPUPolicy *string `json:"cpuPolicy,omitempty" tf:"cpu_policy,omitempty"`

	// Whether enable worker node to support cis security reinforcement, its valid value true or false. Default to false and apply to AliyunLinux series. Use security_hardening_os instead.
	CisEnabled *bool `json:"cisEnabled,omitempty" tf:"cis_enabled,omitempty"`

	// The id of kubernetes cluster.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-alibabacloud/apis/ack/v1alpha1.ManagedKubernetes
	// +crossplane:generate:reference:refFieldName=ClusterIDRefs
	// +crossplane:generate:reference:selectorFieldName=ClusterIDSelector
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Reference to a ManagedKubernetes in ack to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDRefs *v1.Reference `json:"clusterIdRefs,omitempty" tf:"-"`

	// Selector for a ManagedKubernetes in ack to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDSelector *v1.Selector `json:"clusterIdSelector,omitempty" tf:"-"`

	// Specifies whether to automatically create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created due to reasons such as cost or insufficient inventory. This parameter takes effect when you set multi_az_policy to COST_OPTIMIZED. Valid values: true: automatically creates pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created. false: does not create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created.
	CompensateWithOnDemand *bool `json:"compensateWithOnDemand,omitempty" tf:"compensate_with_on_demand,omitempty"`

	// Configure the data disk of the node in the node pool. See data_disks below.
	DataDisks []DataDisksInitParameters `json:"dataDisks,omitempty" tf:"data_disks,omitempty"`

	// The deployment set of node pool. Specify the deploymentSet to ensure that the nodes in the node pool can be distributed on different physical machines.
	DeploymentSetID *string `json:"deploymentSetId,omitempty" tf:"deployment_set_id,omitempty"`

	// Number of expected nodes in the node pool.
	DesiredSize *string `json:"desiredSize,omitempty" tf:"desired_size,omitempty"`

	// Whether to force deletion.
	ForceDelete *bool `json:"forceDelete,omitempty" tf:"force_delete,omitempty"`

	// After you select this check box, if data disks have been attached to the specified ECS instances and the file system of the last data disk is uninitialized, the system automatically formats the last data disk to ext4 and mounts the data disk to /var/lib/docker and /var/lib/kubelet. The original data on the disk will be cleared. Make sure that you back up data in advance. If no data disk is mounted on the ECS instance, no new data disk will be purchased. Default is false.
	FormatDisk *bool `json:"formatDisk,omitempty" tf:"format_disk,omitempty"`

	// The custom image ID. The system-provided image is used by default.
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The operating system image type and the platform parameter can be selected from the following values:
	ImageType *string `json:"imageType,omitempty" tf:"image_type,omitempty"`

	// Whether to install cloud monitoring on the ECS node. After installation, you can view the monitoring information of the created ECS instance in the cloud monitoring console and recommend enable it. Default value: false. Valid values:
	InstallCloudMonitor *bool `json:"installCloudMonitor,omitempty" tf:"install_cloud_monitor,omitempty"`

	// Node payment type. Valid values: PostPaid, PrePaid, default is PostPaid. If value is PrePaid, the arguments period, period_unit, auto_renew and auto_renew_period are required.
	InstanceChargeType *string `json:"instanceChargeType,omitempty" tf:"instance_charge_type,omitempty"`

	// In the node instance specification list, you can select multiple instance specifications as alternatives. When each node is created, it will try to purchase from the first specification until it is created successfully. The final purchased instance specifications may vary with inventory changes.
	InstanceTypes []*string `json:"instanceTypes,omitempty" tf:"instance_types,omitempty"`

	// The instance list. Add existing nodes under the same cluster VPC to the node pool.
	Instances []*string `json:"instances,omitempty" tf:"instances,omitempty"`

	// The billing method for network usage. Valid values PayByBandwidth and PayByTraffic. Conflict with eip_internet_charge_type, EIP and public network IP can only choose one.
	InternetChargeType *string `json:"internetChargeType,omitempty" tf:"internet_charge_type,omitempty"`

	// The maximum bandwidth of the public IP address of the node. The unit is Mbps(Mega bit per second). The value range is:[1,100]
	InternetMaxBandwidthOut *float64 `json:"internetMaxBandwidthOut,omitempty" tf:"internet_max_bandwidth_out,omitempty"`

	// An KMS encrypts password used to a cs kubernetes. You have to specify one of password key_name kms_encrypted_password fields.
	KMSEncryptedPasswordSecretRef *v1.SecretKeySelector `json:"kmsEncryptedPasswordSecretRef,omitempty" tf:"-"`

	// An KMS encryption context used to decrypt kms_encrypted_password before creating or updating a cs kubernetes with kms_encrypted_password. See Encryption Context. It is valid when kms_encrypted_password is set.
	// +mapType=granular
	KMSEncryptionContext map[string]*string `json:"kmsEncryptionContext,omitempty" tf:"kms_encryption_context,omitempty"`

	// Add an existing instance to the node pool, whether to keep the original instance name. It is recommended to set to true.
	KeepInstanceName *bool `json:"keepInstanceName,omitempty" tf:"keep_instance_name,omitempty"`

	// The name of the key pair. When the node pool is a managed node pool, only key_name is supported.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-alibabacloud/apis/ecs/v1alpha1.KeyPair
	KeyName *string `json:"keyName,omitempty" tf:"key_name,omitempty"`

	// Reference to a KeyPair in ecs to populate keyName.
	// +kubebuilder:validation:Optional
	KeyNameRef *v1.Reference `json:"keyNameRef,omitempty" tf:"-"`

	// Selector for a KeyPair in ecs to populate keyName.
	// +kubebuilder:validation:Optional
	KeyNameSelector *v1.Selector `json:"keyNameSelector,omitempty" tf:"-"`

	// Kubelet configuration parameters for worker nodes. See kubelet_configuration below. More information in Kubelet Configuration. See kubelet_configuration below.
	KubeletConfiguration []KubeletConfigurationInitParameters `json:"kubeletConfiguration,omitempty" tf:"kubelet_configuration,omitempty"`

	// A List of Kubernetes labels to assign to the nodes . Only labels that are applied with the ACK API are managed by this argument. Detailed below. More information in Labels. See labels below.
	Labels []LabelsInitParameters `json:"labels,omitempty" tf:"labels,omitempty"`

	// Whether the ECS instance is logged on as a ecs-user user. Valid value: true and false.
	LoginAsNonRoot *bool `json:"loginAsNonRoot,omitempty" tf:"login_as_non_root,omitempty"`

	// Managed node pool configuration. See management below.
	Management []ManagementInitParameters `json:"management,omitempty" tf:"management,omitempty"`

	// The scaling policy for ECS instances in a multi-zone scaling group. Valid value: PRIORITY, COST_OPTIMIZED and BALANCE. PRIORITY: scales the capacity according to the virtual switches you define (VSwitchIds.N). When an ECS instance cannot be created in the zone where the higher-priority vSwitch is located, the next-priority vSwitch is automatically used to create an ECS instance. COST_OPTIMIZED: try to create by vCPU unit price from low to high. When the scaling configuration is configured with multiple instances of preemptible billing, preemptible instances are created first. You can continue to use the CompensateWithOnDemand parameter to specify whether to automatically try to create a preemptible instance by paying for it. It takes effect only when the scaling configuration has multi-instance specifications or preemptible instances. BALANCE: distributes ECS instances evenly among the multi-zone specified by the scaling group. If the zones become unbalanced due to insufficient inventory, you can use the API [RebalanceInstances](~~ 71516 ~~) to balance resources.
	MultiAzPolicy *string `json:"multiAzPolicy,omitempty" tf:"multi_az_policy,omitempty"`

	// (Deprecated since v1.219.0). Field 'name' has been deprecated from provider version 1.219.0. New field 'node_pool_name' instead.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The worker node number of the node pool. From version 1.111.0, node_count is not required.
	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`

	// Each node name consists of a prefix, its private network IP, and a suffix, separated by commas. The input format is customized,,ip,.
	NodeNameMode *string `json:"nodeNameMode,omitempty" tf:"node_name_mode,omitempty"`

	// The name of node pool.
	NodePoolName *string `json:"nodePoolName,omitempty" tf:"node_pool_name,omitempty"`

	// The minimum number of pay-as-you-go instances that must be kept in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferably creates pay-as-you-go instances.
	OnDemandBaseCapacity *string `json:"onDemandBaseCapacity,omitempty" tf:"on_demand_base_capacity,omitempty"`

	// The percentage of pay-as-you-go instances among the extra instances that exceed the number specified by on_demand_base_capacity. Valid values: 0 to 100.
	OnDemandPercentageAboveBaseCapacity *string `json:"onDemandPercentageAboveBaseCapacity,omitempty" tf:"on_demand_percentage_above_base_capacity,omitempty"`

	// The password of ssh login. You have to specify one of password and key_name fields. The password rule is 8 to 30 characters and contains at least three items (upper and lower case letters, numbers, and special symbols).
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// Node payment period. Its valid value is one of {1, 2, 3, 6, 12}.
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// Node payment period unit, valid value: Month. Default is Month.
	PeriodUnit *string `json:"periodUnit,omitempty" tf:"period_unit,omitempty"`

	// Operating system release, using image_type instead.
	Platform *string `json:"platform,omitempty" tf:"platform,omitempty"`

	// Node pre custom data, base64-encoded, the script executed before the node is initialized.
	PreUserData *string `json:"preUserData,omitempty" tf:"pre_user_data,omitempty"`

	// Private node pool configuration. See private_pool_options below.
	PrivatePoolOptions []PrivatePoolOptionsInitParameters `json:"privatePoolOptions,omitempty" tf:"private_pool_options,omitempty"`

	// The name of the Worker RAM role.
	RAMRoleName *string `json:"ramRoleName,omitempty" tf:"ram_role_name,omitempty"`

	// The list of RDS instances.
	RDSInstances []*string `json:"rdsInstances,omitempty" tf:"rds_instances,omitempty"`

	// The ID of the resource group
	ResourceGroupID *string `json:"resourceGroupId,omitempty" tf:"resource_group_id,omitempty"`

	// Rotary configuration. See rolling_policy below.
	RollingPolicy []RollingPolicyInitParameters `json:"rollingPolicy,omitempty" tf:"rolling_policy,omitempty"`

	// Rollout policy is used to specify the strategy when the node pool is rolling update. This field works when node pool updating. Please use rolling_policy to instead it from provider version 1.185.0. See rollout_policy below.
	RolloutPolicy []RolloutPolicyInitParameters `json:"rolloutPolicy,omitempty" tf:"rollout_policy,omitempty"`

	// The runtime name of containers. If not set, the cluster runtime will be used as the node pool runtime. If you select another container runtime, see Comparison of Docker, containerd, and Sandboxed-Container.
	RuntimeName *string `json:"runtimeName,omitempty" tf:"runtime_name,omitempty"`

	// The runtime version of containers. If not set, the cluster runtime will be used as the node pool runtime.
	RuntimeVersion *string `json:"runtimeVersion,omitempty" tf:"runtime_version,omitempty"`

	// Automatic scaling configuration. See scaling_config below.
	ScalingConfig []ScalingConfigInitParameters `json:"scalingConfig,omitempty" tf:"scaling_config,omitempty"`

	// Scaling group mode, default value: release. Valid values:
	ScalingPolicy *string `json:"scalingPolicy,omitempty" tf:"scaling_policy,omitempty"`

	// References to SecurityGroup in ecs to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIDRefs []v1.Reference `json:"securityGroupIdRefs,omitempty" tf:"-"`

	// Selector for a list of SecurityGroup in ecs to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIDSelector *v1.Selector `json:"securityGroupIdSelector,omitempty" tf:"-"`

	// Multiple security groups can be configured for a node pool. If both security_group_ids and security_group_id are configured, security_group_ids takes effect. This field cannot be modified.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-alibabacloud/apis/ecs/v1alpha1.SecurityGroup
	// +crossplane:generate:reference:refFieldName=SecurityGroupIDRefs
	// +crossplane:generate:reference:selectorFieldName=SecurityGroupIDSelector
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// Alibaba Cloud OS security reinforcement. Default value: false. Value:
	// -true: enable Alibaba Cloud OS security reinforcement.
	// -false: does not enable Alibaba Cloud OS security reinforcement.
	SecurityHardeningOs *bool `json:"securityHardeningOs,omitempty" tf:"security_hardening_os,omitempty"`

	// Whether enable worker node to support soc security reinforcement, its valid value true or false. Default to false and apply to AliyunLinux series. See SOC Reinforcement.
	SocEnabled *bool `json:"socEnabled,omitempty" tf:"soc_enabled,omitempty"`

	// The number of instance types that are available. Auto Scaling creates preemptible instances of multiple instance types that are available at the lowest cost. Valid values: 1 to 10.
	SpotInstancePools *float64 `json:"spotInstancePools,omitempty" tf:"spot_instance_pools,omitempty"`

	// Specifies whether to supplement preemptible instances when the number of preemptible instances drops below the specified minimum number. If you set the value to true, Auto Scaling attempts to create a new preemptible instance when the system notifies that an existing preemptible instance is about to be reclaimed. Valid values: true: enables the supplementation of preemptible instances. false: disables the supplementation of preemptible instances.
	SpotInstanceRemedy *bool `json:"spotInstanceRemedy,omitempty" tf:"spot_instance_remedy,omitempty"`

	// The current single preemptible instance type market price range configuration. See spot_price_limit below.
	SpotPriceLimit []SpotPriceLimitInitParameters `json:"spotPriceLimit,omitempty" tf:"spot_price_limit,omitempty"`

	// The preemptible instance type. Value:
	SpotStrategy *string `json:"spotStrategy,omitempty" tf:"spot_strategy,omitempty"`

	// Specifies whether to enable the burst feature for system disks. Valid values:true: enables the burst feature. false: disables the burst feature. This parameter is supported only when system_disk_category is set to cloud_auto.
	SystemDiskBurstingEnabled *bool `json:"systemDiskBurstingEnabled,omitempty" tf:"system_disk_bursting_enabled,omitempty"`

	// The multi-disk categories of the system disk. When a high-priority disk type cannot be used, Auto Scaling automatically tries to create a system disk with the next priority disk category. Valid values see system_disk_category.
	SystemDiskCategories []*string `json:"systemDiskCategories,omitempty" tf:"system_disk_categories,omitempty"`

	// The category of the system disk for nodes. Default value: cloud_efficiency. Valid values:
	SystemDiskCategory *string `json:"systemDiskCategory,omitempty" tf:"system_disk_category,omitempty"`

	// The encryption algorithm used by the system disk. Value range: aes-256.
	SystemDiskEncryptAlgorithm *string `json:"systemDiskEncryptAlgorithm,omitempty" tf:"system_disk_encrypt_algorithm,omitempty"`

	// Whether to encrypt the system disk. Value range: true: encryption. false: Do not encrypt.
	SystemDiskEncrypted *bool `json:"systemDiskEncrypted,omitempty" tf:"system_disk_encrypted,omitempty"`

	// The ID of the KMS key used by the system disk.
	SystemDiskKMSKey *string `json:"systemDiskKmsKey,omitempty" tf:"system_disk_kms_key,omitempty"`

	// The system disk performance of the node takes effect only for the ESSD disk.
	SystemDiskPerformanceLevel *string `json:"systemDiskPerformanceLevel,omitempty" tf:"system_disk_performance_level,omitempty"`

	// The predefined IOPS of a system disk. Valid values: 0 to min{50,000, 1,000  Capacity - Baseline IOPS}. Baseline IOPS = min{1,800 + 50  Capacity, 50,000}. This parameter is supported only when system_disk_category is set to cloud_auto.
	SystemDiskProvisionedIops *float64 `json:"systemDiskProvisionedIops,omitempty" tf:"system_disk_provisioned_iops,omitempty"`

	// The size of the system disk. Unit: GiB. The value of this parameter must be at least 1 and greater than or equal to the image size. Default value: 40 or the size of the image, whichever is larger.
	SystemDiskSize *float64 `json:"systemDiskSize,omitempty" tf:"system_disk_size,omitempty"`

	// The ID of the automatic snapshot policy used by the system disk.
	SystemDiskSnapshotPolicyID *string `json:"systemDiskSnapshotPolicyId,omitempty" tf:"system_disk_snapshot_policy_id,omitempty"`

	// Key-value map of resource tags.
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// A List of Kubernetes taints to assign to the nodes. Detailed below. More information in Taints and Toleration. See taints below.
	Taints []KubernetesNodePoolTaintsInitParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	// The configuration about confidential computing for the cluster. See tee_config below.
	TeeConfig []TeeConfigInitParameters `json:"teeConfig,omitempty" tf:"tee_config,omitempty"`

	// Whether the node after expansion can be scheduled.
	Unschedulable *bool `json:"unschedulable,omitempty" tf:"unschedulable,omitempty"`

	// Synchronously update node labels and taints.
	UpdateNodes *bool `json:"updateNodes,omitempty" tf:"update_nodes,omitempty"`

	// Node custom data, base64-encoded.
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// The vswitches used by node pool workers.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-alibabacloud/apis/vpc/v1alpha1.Vswitch
	VswitchIds []*string `json:"vswitchIds,omitempty" tf:"vswitch_ids,omitempty"`

	// References to Vswitch in vpc to populate vswitchIds.
	// +kubebuilder:validation:Optional
	VswitchIdsRefs []v1.Reference `json:"vswitchIdsRefs,omitempty" tf:"-"`

	// Selector for a list of Vswitch in vpc to populate vswitchIds.
	// +kubebuilder:validation:Optional
	VswitchIdsSelector *v1.Selector `json:"vswitchIdsSelector,omitempty" tf:"-"`
}

type KubernetesNodePoolObservation struct {

	// Whether to enable automatic renewal for nodes in the node pool takes effect only when instance_charge_type is set to PrePaid. Default value: false. Valid values:
	AutoRenew *bool `json:"autoRenew,omitempty" tf:"auto_renew,omitempty"`

	// The automatic renewal period of nodes in the node pool takes effect only when you select Prepaid and Automatic Renewal, and is a required value. When PeriodUnit = Month, the value range is {1, 2, 3, 6, 12}. Default value: 1.
	AutoRenewPeriod *float64 `json:"autoRenewPeriod,omitempty" tf:"auto_renew_period,omitempty"`

	// Node CPU management policies. Default value: none. When the cluster version is 1.12.6 or later, the following two policies are supported:
	CPUPolicy *string `json:"cpuPolicy,omitempty" tf:"cpu_policy,omitempty"`

	// Whether enable worker node to support cis security reinforcement, its valid value true or false. Default to false and apply to AliyunLinux series. Use security_hardening_os instead.
	CisEnabled *bool `json:"cisEnabled,omitempty" tf:"cis_enabled,omitempty"`

	// The id of kubernetes cluster.
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Specifies whether to automatically create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created due to reasons such as cost or insufficient inventory. This parameter takes effect when you set multi_az_policy to COST_OPTIMIZED. Valid values: true: automatically creates pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created. false: does not create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created.
	CompensateWithOnDemand *bool `json:"compensateWithOnDemand,omitempty" tf:"compensate_with_on_demand,omitempty"`

	// Configure the data disk of the node in the node pool. See data_disks below.
	DataDisks []DataDisksObservation `json:"dataDisks,omitempty" tf:"data_disks,omitempty"`

	// The deployment set of node pool. Specify the deploymentSet to ensure that the nodes in the node pool can be distributed on different physical machines.
	DeploymentSetID *string `json:"deploymentSetId,omitempty" tf:"deployment_set_id,omitempty"`

	// Number of expected nodes in the node pool.
	DesiredSize *string `json:"desiredSize,omitempty" tf:"desired_size,omitempty"`

	// Whether to force deletion.
	ForceDelete *bool `json:"forceDelete,omitempty" tf:"force_delete,omitempty"`

	// After you select this check box, if data disks have been attached to the specified ECS instances and the file system of the last data disk is uninitialized, the system automatically formats the last data disk to ext4 and mounts the data disk to /var/lib/docker and /var/lib/kubelet. The original data on the disk will be cleared. Make sure that you back up data in advance. If no data disk is mounted on the ECS instance, no new data disk will be purchased. Default is false.
	FormatDisk *bool `json:"formatDisk,omitempty" tf:"format_disk,omitempty"`

	// The ID of the resource supplied above.The value is formulated as <cluster_id>:<node_pool_id>.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The custom image ID. The system-provided image is used by default.
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The operating system image type and the platform parameter can be selected from the following values:
	ImageType *string `json:"imageType,omitempty" tf:"image_type,omitempty"`

	// Whether to install cloud monitoring on the ECS node. After installation, you can view the monitoring information of the created ECS instance in the cloud monitoring console and recommend enable it. Default value: false. Valid values:
	InstallCloudMonitor *bool `json:"installCloudMonitor,omitempty" tf:"install_cloud_monitor,omitempty"`

	// Node payment type. Valid values: PostPaid, PrePaid, default is PostPaid. If value is PrePaid, the arguments period, period_unit, auto_renew and auto_renew_period are required.
	InstanceChargeType *string `json:"instanceChargeType,omitempty" tf:"instance_charge_type,omitempty"`

	// In the node instance specification list, you can select multiple instance specifications as alternatives. When each node is created, it will try to purchase from the first specification until it is created successfully. The final purchased instance specifications may vary with inventory changes.
	InstanceTypes []*string `json:"instanceTypes,omitempty" tf:"instance_types,omitempty"`

	// The instance list. Add existing nodes under the same cluster VPC to the node pool.
	Instances []*string `json:"instances,omitempty" tf:"instances,omitempty"`

	// The billing method for network usage. Valid values PayByBandwidth and PayByTraffic. Conflict with eip_internet_charge_type, EIP and public network IP can only choose one.
	InternetChargeType *string `json:"internetChargeType,omitempty" tf:"internet_charge_type,omitempty"`

	// The maximum bandwidth of the public IP address of the node. The unit is Mbps(Mega bit per second). The value range is:[1,100]
	InternetMaxBandwidthOut *float64 `json:"internetMaxBandwidthOut,omitempty" tf:"internet_max_bandwidth_out,omitempty"`

	// An KMS encryption context used to decrypt kms_encrypted_password before creating or updating a cs kubernetes with kms_encrypted_password. See Encryption Context. It is valid when kms_encrypted_password is set.
	// +mapType=granular
	KMSEncryptionContext map[string]*string `json:"kmsEncryptionContext,omitempty" tf:"kms_encryption_context,omitempty"`

	// Add an existing instance to the node pool, whether to keep the original instance name. It is recommended to set to true.
	KeepInstanceName *bool `json:"keepInstanceName,omitempty" tf:"keep_instance_name,omitempty"`

	// The name of the key pair. When the node pool is a managed node pool, only key_name is supported.
	KeyName *string `json:"keyName,omitempty" tf:"key_name,omitempty"`

	// Kubelet configuration parameters for worker nodes. See kubelet_configuration below. More information in Kubelet Configuration. See kubelet_configuration below.
	KubeletConfiguration []KubeletConfigurationObservation `json:"kubeletConfiguration,omitempty" tf:"kubelet_configuration,omitempty"`

	// A List of Kubernetes labels to assign to the nodes . Only labels that are applied with the ACK API are managed by this argument. Detailed below. More information in Labels. See labels below.
	Labels []LabelsObservation `json:"labels,omitempty" tf:"labels,omitempty"`

	// Whether the ECS instance is logged on as a ecs-user user. Valid value: true and false.
	LoginAsNonRoot *bool `json:"loginAsNonRoot,omitempty" tf:"login_as_non_root,omitempty"`

	// Managed node pool configuration. See management below.
	Management []ManagementObservation `json:"management,omitempty" tf:"management,omitempty"`

	// The scaling policy for ECS instances in a multi-zone scaling group. Valid value: PRIORITY, COST_OPTIMIZED and BALANCE. PRIORITY: scales the capacity according to the virtual switches you define (VSwitchIds.N). When an ECS instance cannot be created in the zone where the higher-priority vSwitch is located, the next-priority vSwitch is automatically used to create an ECS instance. COST_OPTIMIZED: try to create by vCPU unit price from low to high. When the scaling configuration is configured with multiple instances of preemptible billing, preemptible instances are created first. You can continue to use the CompensateWithOnDemand parameter to specify whether to automatically try to create a preemptible instance by paying for it. It takes effect only when the scaling configuration has multi-instance specifications or preemptible instances. BALANCE: distributes ECS instances evenly among the multi-zone specified by the scaling group. If the zones become unbalanced due to insufficient inventory, you can use the API [RebalanceInstances](~~ 71516 ~~) to balance resources.
	MultiAzPolicy *string `json:"multiAzPolicy,omitempty" tf:"multi_az_policy,omitempty"`

	// (Deprecated since v1.219.0). Field 'name' has been deprecated from provider version 1.219.0. New field 'node_pool_name' instead.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The worker node number of the node pool. From version 1.111.0, node_count is not required.
	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`

	// Each node name consists of a prefix, its private network IP, and a suffix, separated by commas. The input format is customized,,ip,.
	NodeNameMode *string `json:"nodeNameMode,omitempty" tf:"node_name_mode,omitempty"`

	// The first ID of the resource.
	NodePoolID *string `json:"nodePoolId,omitempty" tf:"node_pool_id,omitempty"`

	// The name of node pool.
	NodePoolName *string `json:"nodePoolName,omitempty" tf:"node_pool_name,omitempty"`

	// The minimum number of pay-as-you-go instances that must be kept in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferably creates pay-as-you-go instances.
	OnDemandBaseCapacity *string `json:"onDemandBaseCapacity,omitempty" tf:"on_demand_base_capacity,omitempty"`

	// The percentage of pay-as-you-go instances among the extra instances that exceed the number specified by on_demand_base_capacity. Valid values: 0 to 100.
	OnDemandPercentageAboveBaseCapacity *string `json:"onDemandPercentageAboveBaseCapacity,omitempty" tf:"on_demand_percentage_above_base_capacity,omitempty"`

	// Node payment period. Its valid value is one of {1, 2, 3, 6, 12}.
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// Node payment period unit, valid value: Month. Default is Month.
	PeriodUnit *string `json:"periodUnit,omitempty" tf:"period_unit,omitempty"`

	// Operating system release, using image_type instead.
	Platform *string `json:"platform,omitempty" tf:"platform,omitempty"`

	// Node pre custom data, base64-encoded, the script executed before the node is initialized.
	PreUserData *string `json:"preUserData,omitempty" tf:"pre_user_data,omitempty"`

	// Private node pool configuration. See private_pool_options below.
	PrivatePoolOptions []PrivatePoolOptionsObservation `json:"privatePoolOptions,omitempty" tf:"private_pool_options,omitempty"`

	// The name of the Worker RAM role.
	RAMRoleName *string `json:"ramRoleName,omitempty" tf:"ram_role_name,omitempty"`

	// The list of RDS instances.
	RDSInstances []*string `json:"rdsInstances,omitempty" tf:"rds_instances,omitempty"`

	// The ID of the resource group
	ResourceGroupID *string `json:"resourceGroupId,omitempty" tf:"resource_group_id,omitempty"`

	// Rotary configuration. See rolling_policy below.
	RollingPolicy []RollingPolicyObservation `json:"rollingPolicy,omitempty" tf:"rolling_policy,omitempty"`

	// Rollout policy is used to specify the strategy when the node pool is rolling update. This field works when node pool updating. Please use rolling_policy to instead it from provider version 1.185.0. See rollout_policy below.
	RolloutPolicy []RolloutPolicyObservation `json:"rolloutPolicy,omitempty" tf:"rollout_policy,omitempty"`

	// The runtime name of containers. If not set, the cluster runtime will be used as the node pool runtime. If you select another container runtime, see Comparison of Docker, containerd, and Sandboxed-Container.
	RuntimeName *string `json:"runtimeName,omitempty" tf:"runtime_name,omitempty"`

	// The runtime version of containers. If not set, the cluster runtime will be used as the node pool runtime.
	RuntimeVersion *string `json:"runtimeVersion,omitempty" tf:"runtime_version,omitempty"`

	// Automatic scaling configuration. See scaling_config below.
	ScalingConfig []ScalingConfigObservation `json:"scalingConfig,omitempty" tf:"scaling_config,omitempty"`

	// The ID of the scaling group.
	ScalingGroupID *string `json:"scalingGroupId,omitempty" tf:"scaling_group_id,omitempty"`

	// Scaling group mode, default value: release. Valid values:
	ScalingPolicy *string `json:"scalingPolicy,omitempty" tf:"scaling_policy,omitempty"`

	// Multiple security groups can be configured for a node pool. If both security_group_ids and security_group_id are configured, security_group_ids takes effect. This field cannot be modified.
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// Alibaba Cloud OS security reinforcement. Default value: false. Value:
	// -true: enable Alibaba Cloud OS security reinforcement.
	// -false: does not enable Alibaba Cloud OS security reinforcement.
	SecurityHardeningOs *bool `json:"securityHardeningOs,omitempty" tf:"security_hardening_os,omitempty"`

	// Whether enable worker node to support soc security reinforcement, its valid value true or false. Default to false and apply to AliyunLinux series. See SOC Reinforcement.
	SocEnabled *bool `json:"socEnabled,omitempty" tf:"soc_enabled,omitempty"`

	// The number of instance types that are available. Auto Scaling creates preemptible instances of multiple instance types that are available at the lowest cost. Valid values: 1 to 10.
	SpotInstancePools *float64 `json:"spotInstancePools,omitempty" tf:"spot_instance_pools,omitempty"`

	// Specifies whether to supplement preemptible instances when the number of preemptible instances drops below the specified minimum number. If you set the value to true, Auto Scaling attempts to create a new preemptible instance when the system notifies that an existing preemptible instance is about to be reclaimed. Valid values: true: enables the supplementation of preemptible instances. false: disables the supplementation of preemptible instances.
	SpotInstanceRemedy *bool `json:"spotInstanceRemedy,omitempty" tf:"spot_instance_remedy,omitempty"`

	// The current single preemptible instance type market price range configuration. See spot_price_limit below.
	SpotPriceLimit []SpotPriceLimitObservation `json:"spotPriceLimit,omitempty" tf:"spot_price_limit,omitempty"`

	// The preemptible instance type. Value:
	SpotStrategy *string `json:"spotStrategy,omitempty" tf:"spot_strategy,omitempty"`

	// Specifies whether to enable the burst feature for system disks. Valid values:true: enables the burst feature. false: disables the burst feature. This parameter is supported only when system_disk_category is set to cloud_auto.
	SystemDiskBurstingEnabled *bool `json:"systemDiskBurstingEnabled,omitempty" tf:"system_disk_bursting_enabled,omitempty"`

	// The multi-disk categories of the system disk. When a high-priority disk type cannot be used, Auto Scaling automatically tries to create a system disk with the next priority disk category. Valid values see system_disk_category.
	SystemDiskCategories []*string `json:"systemDiskCategories,omitempty" tf:"system_disk_categories,omitempty"`

	// The category of the system disk for nodes. Default value: cloud_efficiency. Valid values:
	SystemDiskCategory *string `json:"systemDiskCategory,omitempty" tf:"system_disk_category,omitempty"`

	// The encryption algorithm used by the system disk. Value range: aes-256.
	SystemDiskEncryptAlgorithm *string `json:"systemDiskEncryptAlgorithm,omitempty" tf:"system_disk_encrypt_algorithm,omitempty"`

	// Whether to encrypt the system disk. Value range: true: encryption. false: Do not encrypt.
	SystemDiskEncrypted *bool `json:"systemDiskEncrypted,omitempty" tf:"system_disk_encrypted,omitempty"`

	// The ID of the KMS key used by the system disk.
	SystemDiskKMSKey *string `json:"systemDiskKmsKey,omitempty" tf:"system_disk_kms_key,omitempty"`

	// The system disk performance of the node takes effect only for the ESSD disk.
	SystemDiskPerformanceLevel *string `json:"systemDiskPerformanceLevel,omitempty" tf:"system_disk_performance_level,omitempty"`

	// The predefined IOPS of a system disk. Valid values: 0 to min{50,000, 1,000  Capacity - Baseline IOPS}. Baseline IOPS = min{1,800 + 50  Capacity, 50,000}. This parameter is supported only when system_disk_category is set to cloud_auto.
	SystemDiskProvisionedIops *float64 `json:"systemDiskProvisionedIops,omitempty" tf:"system_disk_provisioned_iops,omitempty"`

	// The size of the system disk. Unit: GiB. The value of this parameter must be at least 1 and greater than or equal to the image size. Default value: 40 or the size of the image, whichever is larger.
	SystemDiskSize *float64 `json:"systemDiskSize,omitempty" tf:"system_disk_size,omitempty"`

	// The ID of the automatic snapshot policy used by the system disk.
	SystemDiskSnapshotPolicyID *string `json:"systemDiskSnapshotPolicyId,omitempty" tf:"system_disk_snapshot_policy_id,omitempty"`

	// Key-value map of resource tags.
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// A List of Kubernetes taints to assign to the nodes. Detailed below. More information in Taints and Toleration. See taints below.
	Taints []KubernetesNodePoolTaintsObservation `json:"taints,omitempty" tf:"taints,omitempty"`

	// The configuration about confidential computing for the cluster. See tee_config below.
	TeeConfig []TeeConfigObservation `json:"teeConfig,omitempty" tf:"tee_config,omitempty"`

	// Whether the node after expansion can be scheduled.
	Unschedulable *bool `json:"unschedulable,omitempty" tf:"unschedulable,omitempty"`

	// Synchronously update node labels and taints.
	UpdateNodes *bool `json:"updateNodes,omitempty" tf:"update_nodes,omitempty"`

	// Node custom data, base64-encoded.
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// The ID of the resource supplied above.The value is formulated as <cluster_id>:<node_pool_id>.
	VPCID *string `json:"vpcId,omitempty" tf:"vpc_id,omitempty"`

	// The vswitches used by node pool workers.
	VswitchIds []*string `json:"vswitchIds,omitempty" tf:"vswitch_ids,omitempty"`
}

type KubernetesNodePoolParameters struct {

	// Whether to enable automatic renewal for nodes in the node pool takes effect only when instance_charge_type is set to PrePaid. Default value: false. Valid values:
	// +kubebuilder:validation:Optional
	AutoRenew *bool `json:"autoRenew,omitempty" tf:"auto_renew,omitempty"`

	// The automatic renewal period of nodes in the node pool takes effect only when you select Prepaid and Automatic Renewal, and is a required value. When PeriodUnit = Month, the value range is {1, 2, 3, 6, 12}. Default value: 1.
	// +kubebuilder:validation:Optional
	AutoRenewPeriod *float64 `json:"autoRenewPeriod,omitempty" tf:"auto_renew_period,omitempty"`

	// Node CPU management policies. Default value: none. When the cluster version is 1.12.6 or later, the following two policies are supported:
	// +kubebuilder:validation:Optional
	CPUPolicy *string `json:"cpuPolicy,omitempty" tf:"cpu_policy,omitempty"`

	// Whether enable worker node to support cis security reinforcement, its valid value true or false. Default to false and apply to AliyunLinux series. Use security_hardening_os instead.
	// +kubebuilder:validation:Optional
	CisEnabled *bool `json:"cisEnabled,omitempty" tf:"cis_enabled,omitempty"`

	// The id of kubernetes cluster.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-alibabacloud/apis/ack/v1alpha1.ManagedKubernetes
	// +crossplane:generate:reference:refFieldName=ClusterIDRefs
	// +crossplane:generate:reference:selectorFieldName=ClusterIDSelector
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Reference to a ManagedKubernetes in ack to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDRefs *v1.Reference `json:"clusterIdRefs,omitempty" tf:"-"`

	// Selector for a ManagedKubernetes in ack to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDSelector *v1.Selector `json:"clusterIdSelector,omitempty" tf:"-"`

	// Specifies whether to automatically create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created due to reasons such as cost or insufficient inventory. This parameter takes effect when you set multi_az_policy to COST_OPTIMIZED. Valid values: true: automatically creates pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created. false: does not create pay-as-you-go instances to meet the required number of ECS instances if preemptible instances cannot be created.
	// +kubebuilder:validation:Optional
	CompensateWithOnDemand *bool `json:"compensateWithOnDemand,omitempty" tf:"compensate_with_on_demand,omitempty"`

	// Configure the data disk of the node in the node pool. See data_disks below.
	// +kubebuilder:validation:Optional
	DataDisks []DataDisksParameters `json:"dataDisks,omitempty" tf:"data_disks,omitempty"`

	// The deployment set of node pool. Specify the deploymentSet to ensure that the nodes in the node pool can be distributed on different physical machines.
	// +kubebuilder:validation:Optional
	DeploymentSetID *string `json:"deploymentSetId,omitempty" tf:"deployment_set_id,omitempty"`

	// Number of expected nodes in the node pool.
	// +kubebuilder:validation:Optional
	DesiredSize *string `json:"desiredSize,omitempty" tf:"desired_size,omitempty"`

	// Whether to force deletion.
	// +kubebuilder:validation:Optional
	ForceDelete *bool `json:"forceDelete,omitempty" tf:"force_delete,omitempty"`

	// After you select this check box, if data disks have been attached to the specified ECS instances and the file system of the last data disk is uninitialized, the system automatically formats the last data disk to ext4 and mounts the data disk to /var/lib/docker and /var/lib/kubelet. The original data on the disk will be cleared. Make sure that you back up data in advance. If no data disk is mounted on the ECS instance, no new data disk will be purchased. Default is false.
	// +kubebuilder:validation:Optional
	FormatDisk *bool `json:"formatDisk,omitempty" tf:"format_disk,omitempty"`

	// The custom image ID. The system-provided image is used by default.
	// +kubebuilder:validation:Optional
	ImageID *string `json:"imageId,omitempty" tf:"image_id,omitempty"`

	// The operating system image type and the platform parameter can be selected from the following values:
	// +kubebuilder:validation:Optional
	ImageType *string `json:"imageType,omitempty" tf:"image_type,omitempty"`

	// Whether to install cloud monitoring on the ECS node. After installation, you can view the monitoring information of the created ECS instance in the cloud monitoring console and recommend enable it. Default value: false. Valid values:
	// +kubebuilder:validation:Optional
	InstallCloudMonitor *bool `json:"installCloudMonitor,omitempty" tf:"install_cloud_monitor,omitempty"`

	// Node payment type. Valid values: PostPaid, PrePaid, default is PostPaid. If value is PrePaid, the arguments period, period_unit, auto_renew and auto_renew_period are required.
	// +kubebuilder:validation:Optional
	InstanceChargeType *string `json:"instanceChargeType,omitempty" tf:"instance_charge_type,omitempty"`

	// In the node instance specification list, you can select multiple instance specifications as alternatives. When each node is created, it will try to purchase from the first specification until it is created successfully. The final purchased instance specifications may vary with inventory changes.
	// +kubebuilder:validation:Optional
	InstanceTypes []*string `json:"instanceTypes,omitempty" tf:"instance_types,omitempty"`

	// The instance list. Add existing nodes under the same cluster VPC to the node pool.
	// +kubebuilder:validation:Optional
	Instances []*string `json:"instances,omitempty" tf:"instances,omitempty"`

	// The billing method for network usage. Valid values PayByBandwidth and PayByTraffic. Conflict with eip_internet_charge_type, EIP and public network IP can only choose one.
	// +kubebuilder:validation:Optional
	InternetChargeType *string `json:"internetChargeType,omitempty" tf:"internet_charge_type,omitempty"`

	// The maximum bandwidth of the public IP address of the node. The unit is Mbps(Mega bit per second). The value range is:[1,100]
	// +kubebuilder:validation:Optional
	InternetMaxBandwidthOut *float64 `json:"internetMaxBandwidthOut,omitempty" tf:"internet_max_bandwidth_out,omitempty"`

	// An KMS encrypts password used to a cs kubernetes. You have to specify one of password key_name kms_encrypted_password fields.
	// +kubebuilder:validation:Optional
	KMSEncryptedPasswordSecretRef *v1.SecretKeySelector `json:"kmsEncryptedPasswordSecretRef,omitempty" tf:"-"`

	// An KMS encryption context used to decrypt kms_encrypted_password before creating or updating a cs kubernetes with kms_encrypted_password. See Encryption Context. It is valid when kms_encrypted_password is set.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	KMSEncryptionContext map[string]*string `json:"kmsEncryptionContext,omitempty" tf:"kms_encryption_context,omitempty"`

	// Add an existing instance to the node pool, whether to keep the original instance name. It is recommended to set to true.
	// +kubebuilder:validation:Optional
	KeepInstanceName *bool `json:"keepInstanceName,omitempty" tf:"keep_instance_name,omitempty"`

	// The name of the key pair. When the node pool is a managed node pool, only key_name is supported.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-alibabacloud/apis/ecs/v1alpha1.KeyPair
	// +kubebuilder:validation:Optional
	KeyName *string `json:"keyName,omitempty" tf:"key_name,omitempty"`

	// Reference to a KeyPair in ecs to populate keyName.
	// +kubebuilder:validation:Optional
	KeyNameRef *v1.Reference `json:"keyNameRef,omitempty" tf:"-"`

	// Selector for a KeyPair in ecs to populate keyName.
	// +kubebuilder:validation:Optional
	KeyNameSelector *v1.Selector `json:"keyNameSelector,omitempty" tf:"-"`

	// Kubelet configuration parameters for worker nodes. See kubelet_configuration below. More information in Kubelet Configuration. See kubelet_configuration below.
	// +kubebuilder:validation:Optional
	KubeletConfiguration []KubeletConfigurationParameters `json:"kubeletConfiguration,omitempty" tf:"kubelet_configuration,omitempty"`

	// A List of Kubernetes labels to assign to the nodes . Only labels that are applied with the ACK API are managed by this argument. Detailed below. More information in Labels. See labels below.
	// +kubebuilder:validation:Optional
	Labels []LabelsParameters `json:"labels,omitempty" tf:"labels,omitempty"`

	// Whether the ECS instance is logged on as a ecs-user user. Valid value: true and false.
	// +kubebuilder:validation:Optional
	LoginAsNonRoot *bool `json:"loginAsNonRoot,omitempty" tf:"login_as_non_root,omitempty"`

	// Managed node pool configuration. See management below.
	// +kubebuilder:validation:Optional
	Management []ManagementParameters `json:"management,omitempty" tf:"management,omitempty"`

	// The scaling policy for ECS instances in a multi-zone scaling group. Valid value: PRIORITY, COST_OPTIMIZED and BALANCE. PRIORITY: scales the capacity according to the virtual switches you define (VSwitchIds.N). When an ECS instance cannot be created in the zone where the higher-priority vSwitch is located, the next-priority vSwitch is automatically used to create an ECS instance. COST_OPTIMIZED: try to create by vCPU unit price from low to high. When the scaling configuration is configured with multiple instances of preemptible billing, preemptible instances are created first. You can continue to use the CompensateWithOnDemand parameter to specify whether to automatically try to create a preemptible instance by paying for it. It takes effect only when the scaling configuration has multi-instance specifications or preemptible instances. BALANCE: distributes ECS instances evenly among the multi-zone specified by the scaling group. If the zones become unbalanced due to insufficient inventory, you can use the API [RebalanceInstances](~~ 71516 ~~) to balance resources.
	// +kubebuilder:validation:Optional
	MultiAzPolicy *string `json:"multiAzPolicy,omitempty" tf:"multi_az_policy,omitempty"`

	// (Deprecated since v1.219.0). Field 'name' has been deprecated from provider version 1.219.0. New field 'node_pool_name' instead.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The worker node number of the node pool. From version 1.111.0, node_count is not required.
	// +kubebuilder:validation:Optional
	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`

	// Each node name consists of a prefix, its private network IP, and a suffix, separated by commas. The input format is customized,,ip,.
	// +kubebuilder:validation:Optional
	NodeNameMode *string `json:"nodeNameMode,omitempty" tf:"node_name_mode,omitempty"`

	// The name of node pool.
	// +kubebuilder:validation:Optional
	NodePoolName *string `json:"nodePoolName,omitempty" tf:"node_pool_name,omitempty"`

	// The minimum number of pay-as-you-go instances that must be kept in the scaling group. Valid values: 0 to 1000. If the number of pay-as-you-go instances is less than the value of this parameter, Auto Scaling preferably creates pay-as-you-go instances.
	// +kubebuilder:validation:Optional
	OnDemandBaseCapacity *string `json:"onDemandBaseCapacity,omitempty" tf:"on_demand_base_capacity,omitempty"`

	// The percentage of pay-as-you-go instances among the extra instances that exceed the number specified by on_demand_base_capacity. Valid values: 0 to 100.
	// +kubebuilder:validation:Optional
	OnDemandPercentageAboveBaseCapacity *string `json:"onDemandPercentageAboveBaseCapacity,omitempty" tf:"on_demand_percentage_above_base_capacity,omitempty"`

	// The password of ssh login. You have to specify one of password and key_name fields. The password rule is 8 to 30 characters and contains at least three items (upper and lower case letters, numbers, and special symbols).
	// +kubebuilder:validation:Optional
	PasswordSecretRef *v1.SecretKeySelector `json:"passwordSecretRef,omitempty" tf:"-"`

	// Node payment period. Its valid value is one of {1, 2, 3, 6, 12}.
	// +kubebuilder:validation:Optional
	Period *float64 `json:"period,omitempty" tf:"period,omitempty"`

	// Node payment period unit, valid value: Month. Default is Month.
	// +kubebuilder:validation:Optional
	PeriodUnit *string `json:"periodUnit,omitempty" tf:"period_unit,omitempty"`

	// Operating system release, using image_type instead.
	// +kubebuilder:validation:Optional
	Platform *string `json:"platform,omitempty" tf:"platform,omitempty"`

	// Node pre custom data, base64-encoded, the script executed before the node is initialized.
	// +kubebuilder:validation:Optional
	PreUserData *string `json:"preUserData,omitempty" tf:"pre_user_data,omitempty"`

	// Private node pool configuration. See private_pool_options below.
	// +kubebuilder:validation:Optional
	PrivatePoolOptions []PrivatePoolOptionsParameters `json:"privatePoolOptions,omitempty" tf:"private_pool_options,omitempty"`

	// The name of the Worker RAM role.
	// +kubebuilder:validation:Optional
	RAMRoleName *string `json:"ramRoleName,omitempty" tf:"ram_role_name,omitempty"`

	// The list of RDS instances.
	// +kubebuilder:validation:Optional
	RDSInstances []*string `json:"rdsInstances,omitempty" tf:"rds_instances,omitempty"`

	// Region is the region you'd like your resource to be created in.
	// +upjet:crd:field:TFTag=-
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"-"`

	// The ID of the resource group
	// +kubebuilder:validation:Optional
	ResourceGroupID *string `json:"resourceGroupId,omitempty" tf:"resource_group_id,omitempty"`

	// Rotary configuration. See rolling_policy below.
	// +kubebuilder:validation:Optional
	RollingPolicy []RollingPolicyParameters `json:"rollingPolicy,omitempty" tf:"rolling_policy,omitempty"`

	// Rollout policy is used to specify the strategy when the node pool is rolling update. This field works when node pool updating. Please use rolling_policy to instead it from provider version 1.185.0. See rollout_policy below.
	// +kubebuilder:validation:Optional
	RolloutPolicy []RolloutPolicyParameters `json:"rolloutPolicy,omitempty" tf:"rollout_policy,omitempty"`

	// The runtime name of containers. If not set, the cluster runtime will be used as the node pool runtime. If you select another container runtime, see Comparison of Docker, containerd, and Sandboxed-Container.
	// +kubebuilder:validation:Optional
	RuntimeName *string `json:"runtimeName,omitempty" tf:"runtime_name,omitempty"`

	// The runtime version of containers. If not set, the cluster runtime will be used as the node pool runtime.
	// +kubebuilder:validation:Optional
	RuntimeVersion *string `json:"runtimeVersion,omitempty" tf:"runtime_version,omitempty"`

	// Automatic scaling configuration. See scaling_config below.
	// +kubebuilder:validation:Optional
	ScalingConfig []ScalingConfigParameters `json:"scalingConfig,omitempty" tf:"scaling_config,omitempty"`

	// Scaling group mode, default value: release. Valid values:
	// +kubebuilder:validation:Optional
	ScalingPolicy *string `json:"scalingPolicy,omitempty" tf:"scaling_policy,omitempty"`

	// References to SecurityGroup in ecs to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIDRefs []v1.Reference `json:"securityGroupIdRefs,omitempty" tf:"-"`

	// Selector for a list of SecurityGroup in ecs to populate securityGroupIds.
	// +kubebuilder:validation:Optional
	SecurityGroupIDSelector *v1.Selector `json:"securityGroupIdSelector,omitempty" tf:"-"`

	// Multiple security groups can be configured for a node pool. If both security_group_ids and security_group_id are configured, security_group_ids takes effect. This field cannot be modified.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-alibabacloud/apis/ecs/v1alpha1.SecurityGroup
	// +crossplane:generate:reference:refFieldName=SecurityGroupIDRefs
	// +crossplane:generate:reference:selectorFieldName=SecurityGroupIDSelector
	// +kubebuilder:validation:Optional
	SecurityGroupIds []*string `json:"securityGroupIds,omitempty" tf:"security_group_ids,omitempty"`

	// Alibaba Cloud OS security reinforcement. Default value: false. Value:
	// -true: enable Alibaba Cloud OS security reinforcement.
	// -false: does not enable Alibaba Cloud OS security reinforcement.
	// +kubebuilder:validation:Optional
	SecurityHardeningOs *bool `json:"securityHardeningOs,omitempty" tf:"security_hardening_os,omitempty"`

	// Whether enable worker node to support soc security reinforcement, its valid value true or false. Default to false and apply to AliyunLinux series. See SOC Reinforcement.
	// +kubebuilder:validation:Optional
	SocEnabled *bool `json:"socEnabled,omitempty" tf:"soc_enabled,omitempty"`

	// The number of instance types that are available. Auto Scaling creates preemptible instances of multiple instance types that are available at the lowest cost. Valid values: 1 to 10.
	// +kubebuilder:validation:Optional
	SpotInstancePools *float64 `json:"spotInstancePools,omitempty" tf:"spot_instance_pools,omitempty"`

	// Specifies whether to supplement preemptible instances when the number of preemptible instances drops below the specified minimum number. If you set the value to true, Auto Scaling attempts to create a new preemptible instance when the system notifies that an existing preemptible instance is about to be reclaimed. Valid values: true: enables the supplementation of preemptible instances. false: disables the supplementation of preemptible instances.
	// +kubebuilder:validation:Optional
	SpotInstanceRemedy *bool `json:"spotInstanceRemedy,omitempty" tf:"spot_instance_remedy,omitempty"`

	// The current single preemptible instance type market price range configuration. See spot_price_limit below.
	// +kubebuilder:validation:Optional
	SpotPriceLimit []SpotPriceLimitParameters `json:"spotPriceLimit,omitempty" tf:"spot_price_limit,omitempty"`

	// The preemptible instance type. Value:
	// +kubebuilder:validation:Optional
	SpotStrategy *string `json:"spotStrategy,omitempty" tf:"spot_strategy,omitempty"`

	// Specifies whether to enable the burst feature for system disks. Valid values:true: enables the burst feature. false: disables the burst feature. This parameter is supported only when system_disk_category is set to cloud_auto.
	// +kubebuilder:validation:Optional
	SystemDiskBurstingEnabled *bool `json:"systemDiskBurstingEnabled,omitempty" tf:"system_disk_bursting_enabled,omitempty"`

	// The multi-disk categories of the system disk. When a high-priority disk type cannot be used, Auto Scaling automatically tries to create a system disk with the next priority disk category. Valid values see system_disk_category.
	// +kubebuilder:validation:Optional
	SystemDiskCategories []*string `json:"systemDiskCategories,omitempty" tf:"system_disk_categories,omitempty"`

	// The category of the system disk for nodes. Default value: cloud_efficiency. Valid values:
	// +kubebuilder:validation:Optional
	SystemDiskCategory *string `json:"systemDiskCategory,omitempty" tf:"system_disk_category,omitempty"`

	// The encryption algorithm used by the system disk. Value range: aes-256.
	// +kubebuilder:validation:Optional
	SystemDiskEncryptAlgorithm *string `json:"systemDiskEncryptAlgorithm,omitempty" tf:"system_disk_encrypt_algorithm,omitempty"`

	// Whether to encrypt the system disk. Value range: true: encryption. false: Do not encrypt.
	// +kubebuilder:validation:Optional
	SystemDiskEncrypted *bool `json:"systemDiskEncrypted,omitempty" tf:"system_disk_encrypted,omitempty"`

	// The ID of the KMS key used by the system disk.
	// +kubebuilder:validation:Optional
	SystemDiskKMSKey *string `json:"systemDiskKmsKey,omitempty" tf:"system_disk_kms_key,omitempty"`

	// The system disk performance of the node takes effect only for the ESSD disk.
	// +kubebuilder:validation:Optional
	SystemDiskPerformanceLevel *string `json:"systemDiskPerformanceLevel,omitempty" tf:"system_disk_performance_level,omitempty"`

	// The predefined IOPS of a system disk. Valid values: 0 to min{50,000, 1,000  Capacity - Baseline IOPS}. Baseline IOPS = min{1,800 + 50  Capacity, 50,000}. This parameter is supported only when system_disk_category is set to cloud_auto.
	// +kubebuilder:validation:Optional
	SystemDiskProvisionedIops *float64 `json:"systemDiskProvisionedIops,omitempty" tf:"system_disk_provisioned_iops,omitempty"`

	// The size of the system disk. Unit: GiB. The value of this parameter must be at least 1 and greater than or equal to the image size. Default value: 40 or the size of the image, whichever is larger.
	// +kubebuilder:validation:Optional
	SystemDiskSize *float64 `json:"systemDiskSize,omitempty" tf:"system_disk_size,omitempty"`

	// The ID of the automatic snapshot policy used by the system disk.
	// +kubebuilder:validation:Optional
	SystemDiskSnapshotPolicyID *string `json:"systemDiskSnapshotPolicyId,omitempty" tf:"system_disk_snapshot_policy_id,omitempty"`

	// Key-value map of resource tags.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// A List of Kubernetes taints to assign to the nodes. Detailed below. More information in Taints and Toleration. See taints below.
	// +kubebuilder:validation:Optional
	Taints []KubernetesNodePoolTaintsParameters `json:"taints,omitempty" tf:"taints,omitempty"`

	// The configuration about confidential computing for the cluster. See tee_config below.
	// +kubebuilder:validation:Optional
	TeeConfig []TeeConfigParameters `json:"teeConfig,omitempty" tf:"tee_config,omitempty"`

	// Whether the node after expansion can be scheduled.
	// +kubebuilder:validation:Optional
	Unschedulable *bool `json:"unschedulable,omitempty" tf:"unschedulable,omitempty"`

	// Synchronously update node labels and taints.
	// +kubebuilder:validation:Optional
	UpdateNodes *bool `json:"updateNodes,omitempty" tf:"update_nodes,omitempty"`

	// Node custom data, base64-encoded.
	// +kubebuilder:validation:Optional
	UserData *string `json:"userData,omitempty" tf:"user_data,omitempty"`

	// The vswitches used by node pool workers.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-alibabacloud/apis/vpc/v1alpha1.Vswitch
	// +kubebuilder:validation:Optional
	VswitchIds []*string `json:"vswitchIds,omitempty" tf:"vswitch_ids,omitempty"`

	// References to Vswitch in vpc to populate vswitchIds.
	// +kubebuilder:validation:Optional
	VswitchIdsRefs []v1.Reference `json:"vswitchIdsRefs,omitempty" tf:"-"`

	// Selector for a list of Vswitch in vpc to populate vswitchIds.
	// +kubebuilder:validation:Optional
	VswitchIdsSelector *v1.Selector `json:"vswitchIdsSelector,omitempty" tf:"-"`
}

type KubernetesNodePoolTaintsInitParameters struct {

	// The scheduling policy.
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The key of a taint.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The value of a taint.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type KubernetesNodePoolTaintsObservation struct {

	// The scheduling policy.
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The key of a taint.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The value of a taint.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type KubernetesNodePoolTaintsParameters struct {

	// The scheduling policy.
	// +kubebuilder:validation:Optional
	Effect *string `json:"effect,omitempty" tf:"effect,omitempty"`

	// The key of a taint.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// The value of a taint.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type LabelsInitParameters struct {

	// The label key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The label value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type LabelsObservation struct {

	// The label key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The label value.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type LabelsParameters struct {

	// The label key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// The label value.
	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ManagementInitParameters struct {

	// Whether to enable automatic repair. Valid values: true: Automatic repair. false: not automatically repaired.
	AutoRepair *bool `json:"autoRepair,omitempty" tf:"auto_repair,omitempty"`

	// Automatic repair node policy. See auto_repair_policy below.
	AutoRepairPolicy []AutoRepairPolicyInitParameters `json:"autoRepairPolicy,omitempty" tf:"auto_repair_policy,omitempty"`

	// Specifies whether to enable auto update. Valid values: true: enables auto update. false: disables auto update.
	AutoUpgrade *bool `json:"autoUpgrade,omitempty" tf:"auto_upgrade,omitempty"`

	// The auto update policy. See auto_upgrade_policy below.
	AutoUpgradePolicy []AutoUpgradePolicyInitParameters `json:"autoUpgradePolicy,omitempty" tf:"auto_upgrade_policy,omitempty"`

	// Specifies whether to automatically patch CVE vulnerabilities. Valid values: true, false.
	AutoVulFix *bool `json:"autoVulFix,omitempty" tf:"auto_vul_fix,omitempty"`

	// The auto CVE patching policy. See auto_vul_fix_policy below.
	AutoVulFixPolicy []AutoVulFixPolicyInitParameters `json:"autoVulFixPolicy,omitempty" tf:"auto_vul_fix_policy,omitempty"`

	// Specifies whether to enable the managed node pool feature. Valid values: true: enables the managed node pool feature. false: disables the managed node pool feature. Other parameters in this section take effect only when you specify enable=true.
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Maximum number of unavailable nodes. Default value: 1. Value range:[1,1000].
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`

	// Number of additional nodes. You have to specify one of surge, surge_percentage.
	Surge *float64 `json:"surge,omitempty" tf:"surge,omitempty"`

	// Proportion of additional nodes. You have to specify one of surge, surge_percentage.
	SurgePercentage *float64 `json:"surgePercentage,omitempty" tf:"surge_percentage,omitempty"`
}

type ManagementObservation struct {

	// Whether to enable automatic repair. Valid values: true: Automatic repair. false: not automatically repaired.
	AutoRepair *bool `json:"autoRepair,omitempty" tf:"auto_repair,omitempty"`

	// Automatic repair node policy. See auto_repair_policy below.
	AutoRepairPolicy []AutoRepairPolicyObservation `json:"autoRepairPolicy,omitempty" tf:"auto_repair_policy,omitempty"`

	// Specifies whether to enable auto update. Valid values: true: enables auto update. false: disables auto update.
	AutoUpgrade *bool `json:"autoUpgrade,omitempty" tf:"auto_upgrade,omitempty"`

	// The auto update policy. See auto_upgrade_policy below.
	AutoUpgradePolicy []AutoUpgradePolicyObservation `json:"autoUpgradePolicy,omitempty" tf:"auto_upgrade_policy,omitempty"`

	// Specifies whether to automatically patch CVE vulnerabilities. Valid values: true, false.
	AutoVulFix *bool `json:"autoVulFix,omitempty" tf:"auto_vul_fix,omitempty"`

	// The auto CVE patching policy. See auto_vul_fix_policy below.
	AutoVulFixPolicy []AutoVulFixPolicyObservation `json:"autoVulFixPolicy,omitempty" tf:"auto_vul_fix_policy,omitempty"`

	// Specifies whether to enable the managed node pool feature. Valid values: true: enables the managed node pool feature. false: disables the managed node pool feature. Other parameters in this section take effect only when you specify enable=true.
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Maximum number of unavailable nodes. Default value: 1. Value range:[1,1000].
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`

	// Number of additional nodes. You have to specify one of surge, surge_percentage.
	Surge *float64 `json:"surge,omitempty" tf:"surge,omitempty"`

	// Proportion of additional nodes. You have to specify one of surge, surge_percentage.
	SurgePercentage *float64 `json:"surgePercentage,omitempty" tf:"surge_percentage,omitempty"`
}

type ManagementParameters struct {

	// Whether to enable automatic repair. Valid values: true: Automatic repair. false: not automatically repaired.
	// +kubebuilder:validation:Optional
	AutoRepair *bool `json:"autoRepair,omitempty" tf:"auto_repair,omitempty"`

	// Automatic repair node policy. See auto_repair_policy below.
	// +kubebuilder:validation:Optional
	AutoRepairPolicy []AutoRepairPolicyParameters `json:"autoRepairPolicy,omitempty" tf:"auto_repair_policy,omitempty"`

	// Specifies whether to enable auto update. Valid values: true: enables auto update. false: disables auto update.
	// +kubebuilder:validation:Optional
	AutoUpgrade *bool `json:"autoUpgrade,omitempty" tf:"auto_upgrade,omitempty"`

	// The auto update policy. See auto_upgrade_policy below.
	// +kubebuilder:validation:Optional
	AutoUpgradePolicy []AutoUpgradePolicyParameters `json:"autoUpgradePolicy,omitempty" tf:"auto_upgrade_policy,omitempty"`

	// Specifies whether to automatically patch CVE vulnerabilities. Valid values: true, false.
	// +kubebuilder:validation:Optional
	AutoVulFix *bool `json:"autoVulFix,omitempty" tf:"auto_vul_fix,omitempty"`

	// The auto CVE patching policy. See auto_vul_fix_policy below.
	// +kubebuilder:validation:Optional
	AutoVulFixPolicy []AutoVulFixPolicyParameters `json:"autoVulFixPolicy,omitempty" tf:"auto_vul_fix_policy,omitempty"`

	// Specifies whether to enable the managed node pool feature. Valid values: true: enables the managed node pool feature. false: disables the managed node pool feature. Other parameters in this section take effect only when you specify enable=true.
	// +kubebuilder:validation:Optional
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Maximum number of unavailable nodes. Default value: 1. Value range:[1,1000].
	// +kubebuilder:validation:Optional
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`

	// Number of additional nodes. You have to specify one of surge, surge_percentage.
	// +kubebuilder:validation:Optional
	Surge *float64 `json:"surge,omitempty" tf:"surge,omitempty"`

	// Proportion of additional nodes. You have to specify one of surge, surge_percentage.
	// +kubebuilder:validation:Optional
	SurgePercentage *float64 `json:"surgePercentage,omitempty" tf:"surge_percentage,omitempty"`
}

type PrivatePoolOptionsInitParameters struct {

	// The ID of the private node pool.
	PrivatePoolOptionsID *string `json:"privatePoolOptionsId,omitempty" tf:"private_pool_options_id,omitempty"`

	// The type of private node pool. This parameter specifies the type of the private pool that you want to use to create instances. A private node pool is generated when an elasticity assurance or a capacity reservation service takes effect. The system selects a private node pool to launch instances. Valid values: Open: specifies an open private node pool. The system selects an open private node pool to launch instances. If no matching open private node pool is available, the resources in the public node pool are used. Target: specifies a private node pool. The system uses the resources of the specified private node pool to launch instances. If the specified private node pool is unavailable, instances cannot be started. None: no private node pool is used. The resources of private node pools are not used to launch the instances.
	PrivatePoolOptionsMatchCriteria *string `json:"privatePoolOptionsMatchCriteria,omitempty" tf:"private_pool_options_match_criteria,omitempty"`
}

type PrivatePoolOptionsObservation struct {

	// The ID of the private node pool.
	PrivatePoolOptionsID *string `json:"privatePoolOptionsId,omitempty" tf:"private_pool_options_id,omitempty"`

	// The type of private node pool. This parameter specifies the type of the private pool that you want to use to create instances. A private node pool is generated when an elasticity assurance or a capacity reservation service takes effect. The system selects a private node pool to launch instances. Valid values: Open: specifies an open private node pool. The system selects an open private node pool to launch instances. If no matching open private node pool is available, the resources in the public node pool are used. Target: specifies a private node pool. The system uses the resources of the specified private node pool to launch instances. If the specified private node pool is unavailable, instances cannot be started. None: no private node pool is used. The resources of private node pools are not used to launch the instances.
	PrivatePoolOptionsMatchCriteria *string `json:"privatePoolOptionsMatchCriteria,omitempty" tf:"private_pool_options_match_criteria,omitempty"`
}

type PrivatePoolOptionsParameters struct {

	// The ID of the private node pool.
	// +kubebuilder:validation:Optional
	PrivatePoolOptionsID *string `json:"privatePoolOptionsId,omitempty" tf:"private_pool_options_id,omitempty"`

	// The type of private node pool. This parameter specifies the type of the private pool that you want to use to create instances. A private node pool is generated when an elasticity assurance or a capacity reservation service takes effect. The system selects a private node pool to launch instances. Valid values: Open: specifies an open private node pool. The system selects an open private node pool to launch instances. If no matching open private node pool is available, the resources in the public node pool are used. Target: specifies a private node pool. The system uses the resources of the specified private node pool to launch instances. If the specified private node pool is unavailable, instances cannot be started. None: no private node pool is used. The resources of private node pools are not used to launch the instances.
	// +kubebuilder:validation:Optional
	PrivatePoolOptionsMatchCriteria *string `json:"privatePoolOptionsMatchCriteria,omitempty" tf:"private_pool_options_match_criteria,omitempty"`
}

type ReservedMemoryInitParameters struct {

	// Memory resource limit.
	// +mapType=granular
	Limits map[string]*string `json:"limits,omitempty" tf:"limits,omitempty"`

	// The NUMA node.
	NumaNode *float64 `json:"numaNode,omitempty" tf:"numa_node,omitempty"`
}

type ReservedMemoryObservation struct {

	// Memory resource limit.
	// +mapType=granular
	Limits map[string]*string `json:"limits,omitempty" tf:"limits,omitempty"`

	// The NUMA node.
	NumaNode *float64 `json:"numaNode,omitempty" tf:"numa_node,omitempty"`
}

type ReservedMemoryParameters struct {

	// Memory resource limit.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Limits map[string]*string `json:"limits,omitempty" tf:"limits,omitempty"`

	// The NUMA node.
	// +kubebuilder:validation:Optional
	NumaNode *float64 `json:"numaNode,omitempty" tf:"numa_node,omitempty"`
}

type RollingPolicyInitParameters struct {

	// The maximum number of unusable nodes.
	MaxParallelism *float64 `json:"maxParallelism,omitempty" tf:"max_parallelism,omitempty"`
}

type RollingPolicyObservation struct {

	// The maximum number of unusable nodes.
	MaxParallelism *float64 `json:"maxParallelism,omitempty" tf:"max_parallelism,omitempty"`
}

type RollingPolicyParameters struct {

	// The maximum number of unusable nodes.
	// +kubebuilder:validation:Optional
	MaxParallelism *float64 `json:"maxParallelism,omitempty" tf:"max_parallelism,omitempty"`
}

type RolloutPolicyInitParameters struct {

	// Maximum number of unavailable nodes during rolling upgrade. The value of this field should be greater than 0, and if it's set to a number less than or equal to 0, the default setting will be used. Please use max_parallelism to instead it from provider version 1.185.0.
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type RolloutPolicyObservation struct {

	// Maximum number of unavailable nodes during rolling upgrade. The value of this field should be greater than 0, and if it's set to a number less than or equal to 0, the default setting will be used. Please use max_parallelism to instead it from provider version 1.185.0.
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type RolloutPolicyParameters struct {

	// Maximum number of unavailable nodes during rolling upgrade. The value of this field should be greater than 0, and if it's set to a number less than or equal to 0, the default setting will be used. Please use max_parallelism to instead it from provider version 1.185.0.
	// +kubebuilder:validation:Optional
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

type ScalingConfigInitParameters struct {

	// Peak EIP bandwidth. Its valid value range [1~500] in Mbps. It works if is_bond_eip=true. Default to 5.
	EIPBandwidth *float64 `json:"eipBandwidth,omitempty" tf:"eip_bandwidth,omitempty"`

	// EIP billing type. PayByBandwidth: Charged at fixed bandwidth. PayByTraffic: Billed as used traffic. Default: PayByBandwidth. It works if is_bond_eip=true, conflict with internet_charge_type. EIP and public network IP can only choose one.
	EIPInternetChargeType *string `json:"eipInternetChargeType,omitempty" tf:"eip_internet_charge_type,omitempty"`

	// Whether to enable automatic scaling. Value:
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Whether to bind EIP for an instance. Default: false.
	IsBondEIP *bool `json:"isBondEip,omitempty" tf:"is_bond_eip,omitempty"`

	// Max number of instances in a auto scaling group, its valid value range [0~1000]. max_size has to be greater than min_size.
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// Min number of instances in a auto scaling group, its valid value range [0~1000].
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// Instance classification, not required. Vaild value: cpu, gpu, gpushare and spot. Default: cpu. The actual instance type is determined by instance_types.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ScalingConfigObservation struct {

	// Peak EIP bandwidth. Its valid value range [1~500] in Mbps. It works if is_bond_eip=true. Default to 5.
	EIPBandwidth *float64 `json:"eipBandwidth,omitempty" tf:"eip_bandwidth,omitempty"`

	// EIP billing type. PayByBandwidth: Charged at fixed bandwidth. PayByTraffic: Billed as used traffic. Default: PayByBandwidth. It works if is_bond_eip=true, conflict with internet_charge_type. EIP and public network IP can only choose one.
	EIPInternetChargeType *string `json:"eipInternetChargeType,omitempty" tf:"eip_internet_charge_type,omitempty"`

	// Whether to enable automatic scaling. Value:
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Whether to bind EIP for an instance. Default: false.
	IsBondEIP *bool `json:"isBondEip,omitempty" tf:"is_bond_eip,omitempty"`

	// Max number of instances in a auto scaling group, its valid value range [0~1000]. max_size has to be greater than min_size.
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// Min number of instances in a auto scaling group, its valid value range [0~1000].
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// Instance classification, not required. Vaild value: cpu, gpu, gpushare and spot. Default: cpu. The actual instance type is determined by instance_types.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ScalingConfigParameters struct {

	// Peak EIP bandwidth. Its valid value range [1~500] in Mbps. It works if is_bond_eip=true. Default to 5.
	// +kubebuilder:validation:Optional
	EIPBandwidth *float64 `json:"eipBandwidth,omitempty" tf:"eip_bandwidth,omitempty"`

	// EIP billing type. PayByBandwidth: Charged at fixed bandwidth. PayByTraffic: Billed as used traffic. Default: PayByBandwidth. It works if is_bond_eip=true, conflict with internet_charge_type. EIP and public network IP can only choose one.
	// +kubebuilder:validation:Optional
	EIPInternetChargeType *string `json:"eipInternetChargeType,omitempty" tf:"eip_internet_charge_type,omitempty"`

	// Whether to enable automatic scaling. Value:
	// +kubebuilder:validation:Optional
	Enable *bool `json:"enable,omitempty" tf:"enable,omitempty"`

	// Whether to bind EIP for an instance. Default: false.
	// +kubebuilder:validation:Optional
	IsBondEIP *bool `json:"isBondEip,omitempty" tf:"is_bond_eip,omitempty"`

	// Max number of instances in a auto scaling group, its valid value range [0~1000]. max_size has to be greater than min_size.
	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// Min number of instances in a auto scaling group, its valid value range [0~1000].
	// +kubebuilder:validation:Optional
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// Instance classification, not required. Vaild value: cpu, gpu, gpushare and spot. Default: cpu. The actual instance type is determined by instance_types.
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type SpotPriceLimitInitParameters struct {

	// The type of the preemptible instance.
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// The maximum price of a single instance.
	PriceLimit *string `json:"priceLimit,omitempty" tf:"price_limit,omitempty"`
}

type SpotPriceLimitObservation struct {

	// The type of the preemptible instance.
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// The maximum price of a single instance.
	PriceLimit *string `json:"priceLimit,omitempty" tf:"price_limit,omitempty"`
}

type SpotPriceLimitParameters struct {

	// The type of the preemptible instance.
	// +kubebuilder:validation:Optional
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// The maximum price of a single instance.
	// +kubebuilder:validation:Optional
	PriceLimit *string `json:"priceLimit,omitempty" tf:"price_limit,omitempty"`
}

type TeeConfigInitParameters struct {

	// Specifies whether to enable confidential computing for the cluster.
	TeeEnable *bool `json:"teeEnable,omitempty" tf:"tee_enable,omitempty"`
}

type TeeConfigObservation struct {

	// Specifies whether to enable confidential computing for the cluster.
	TeeEnable *bool `json:"teeEnable,omitempty" tf:"tee_enable,omitempty"`
}

type TeeConfigParameters struct {

	// Specifies whether to enable confidential computing for the cluster.
	// +kubebuilder:validation:Optional
	TeeEnable *bool `json:"teeEnable,omitempty" tf:"tee_enable,omitempty"`
}

type TracingInitParameters struct {

	// The endpoint of the collector.
	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// Number of samples to be collected per million span.
	SamplingRatePerMillion *string `json:"samplingRatePerMillion,omitempty" tf:"sampling_rate_per_million,omitempty"`
}

type TracingObservation struct {

	// The endpoint of the collector.
	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// Number of samples to be collected per million span.
	SamplingRatePerMillion *string `json:"samplingRatePerMillion,omitempty" tf:"sampling_rate_per_million,omitempty"`
}

type TracingParameters struct {

	// The endpoint of the collector.
	// +kubebuilder:validation:Optional
	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`

	// Number of samples to be collected per million span.
	// +kubebuilder:validation:Optional
	SamplingRatePerMillion *string `json:"samplingRatePerMillion,omitempty" tf:"sampling_rate_per_million,omitempty"`
}

// KubernetesNodePoolSpec defines the desired state of KubernetesNodePool
type KubernetesNodePoolSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     KubernetesNodePoolParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider KubernetesNodePoolInitParameters `json:"initProvider,omitempty"`
}

// KubernetesNodePoolStatus defines the observed state of KubernetesNodePool.
type KubernetesNodePoolStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        KubernetesNodePoolObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// KubernetesNodePool is the Schema for the KubernetesNodePools API. Provides a Alicloud Container Service for Kubernetes (ACK) Nodepool resource.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,alibabacloud}
type KubernetesNodePool struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.instanceTypes) || (has(self.initProvider) && has(self.initProvider.instanceTypes))",message="spec.forProvider.instanceTypes is a required parameter"
	Spec   KubernetesNodePoolSpec   `json:"spec"`
	Status KubernetesNodePoolStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// KubernetesNodePoolList contains a list of KubernetesNodePools
type KubernetesNodePoolList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []KubernetesNodePool `json:"items"`
}

// Repository type metadata.
var (
	KubernetesNodePool_Kind             = "KubernetesNodePool"
	KubernetesNodePool_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: KubernetesNodePool_Kind}.String()
	KubernetesNodePool_KindAPIVersion   = KubernetesNodePool_Kind + "." + CRDGroupVersion.String()
	KubernetesNodePool_GroupVersionKind = CRDGroupVersion.WithKind(KubernetesNodePool_Kind)
)

func init() {
	SchemeBuilder.Register(&KubernetesNodePool{}, &KubernetesNodePoolList{})
}
